/*****************************************************************
  File name :  fixopt_adpcm.c

  Created by:  martinez, Mon Nov  8 18:01:39 1993

  generated by the DESCARTES Code Generator, Release 2.2
  IS2, 1993
*****************************************************************/

#include "fixopt_adpcm.h"

/*****************************************************************
  C function definition of model fork
*****************************************************************/
void dc_fork_0 ( INPUT,
                 OUTPUT1,OUTPUT2,
                 nBlock
                 )
int *INPUT;
int *OUTPUT1;
int *OUTPUT2;
long nBlock;
{
       
    *OUTPUT1++ =
    *OUTPUT2++ =
      *INPUT++ ;

}


/*****************************************************************
  C function definition of model fork
*****************************************************************/
void dc_fork_2 ( INPUT,
                 OUTPUT1,OUTPUT2,OUTPUT3,OUTPUT4,OUTPUT5,
                 OUTPUT6,OUTPUT7,
                 nBlock
                 )
int *INPUT;
int *OUTPUT1;
int *OUTPUT2;
int *OUTPUT3;
int *OUTPUT4;
int *OUTPUT5;
int *OUTPUT6;
int *OUTPUT7;
long nBlock;
{
       
    *OUTPUT1++ =
    *OUTPUT2++ =
    *OUTPUT3++ =
    *OUTPUT4++ =
    *OUTPUT5++ =
    *OUTPUT6++ =
    *OUTPUT7++ =
      *INPUT++ ;

}


/*****************************************************************
  C function definition of model fork
*****************************************************************/
void dc_fork_1 ( INPUT,
                 OUTPUT1,OUTPUT2,OUTPUT3,
                 nBlock
                 )
int *INPUT;
int *OUTPUT1;
int *OUTPUT2;
int *OUTPUT3;
long nBlock;
{
       
    *OUTPUT1++ =
    *OUTPUT2++ =
    *OUTPUT3++ =
      *INPUT++ ;

}


/*****************************************************************
  C function definition of model const_int
*****************************************************************/
void dc_const_int_0 ( Output,
                      ConstantValue
                      )
register int *Output;
register int ConstantValue;
{


  *Output = ConstantValue; 


}


/*****************************************************************
  C function definition of model scale_factor
*****************************************************************/
void dc_scale_factor_0 ( L,AL,
                         Y,YL,
                         Y_L,LAST_Y
                         )
register int *L;
register int *AL;
register int *Y;
register int *YL;
register int *Y_L;
register int *LAST_Y;
{

  static int W[] = 
    {
      4084, 18, 41, 64, 112, 198, 255, 1122
    } ; 
  
  register int TMP, YUP, YLP ;
  
  /* FUNCTW, map quantizer output into 
     logarithmic version of scale factor multiplier */
  
  TMP = W[(*L>>3) ? (15-*L) & 7 : *L & 7] ;
  
  /* FILTD, update of fast quantizer scale factor */
  
  TMP = ((TMP<<5) + 131072 -  (*LAST_Y) ) & 131071 ; 
  YUP = (TMP>>16) ? (TMP>>5) + 4096 : (TMP>>5) ; 
  YUP = (YUP +  (*LAST_Y) ) & 8191 ; 
  
  /* LIMB, limit quantizer scale factor */
  
    /* Set upper limit to 10.0 */
  if (( ( (YUP + 11264) & 16383) >> 13) == 0) YUP = 5120 ; 
    /* Set lower limit to 1.06 */
  if (( ( (YUP + 15840) & 16383) >> 13) == 1) YUP = 544  ; 
  
  /* FILTE, update of slow quantizer scale factor */
  
  TMP = (YUP + ((1048576 -  (*Y_L) ) >> 6)) & 16383 ; 
  TMP = (TMP >> 13) ? TMP + 507904 : TMP ; 
  YLP = (TMP +  (*Y_L) ) & 524287 ; 
  
  /* MIX, form linear combination of fast and slow quantizer scale factors */
  
  TMP    = (YUP + 16384 - ( (*Y_L)  >> 6)) & 16383 ; 
   (*LAST_Y)  =  TMP >> 13 ; /*  (*LAST_Y)  is used here as a temp variable */
  TMP    = ( (*LAST_Y)  == 1) ? (16384 - TMP) & 8191  : TMP ; 
  TMP    = (TMP * *AL) >> 6 ; 
  TMP    = ( (*LAST_Y)  == 1) ? (16384 - TMP) & 16383 : TMP ; 
  
  /* calculate new Y */
  /* Output samples */
  /* Store new states */
 
   (*LAST_Y)  = *Y = (( (*Y_L)  >> 6) + TMP) & 8191 ; 
  *YL =  (*Y_L)  ; 
   (*Y_L)  = YLP ;


}


/*****************************************************************
  C function definition of model iadpt_quant
*****************************************************************/
void dc_iadpt_quant_0 ( I,Y,
                        DQ
                        )
register int *I;
register int *Y;
register int *DQ;
{

  static int qtab[] =
    {
      2048, 4, 135, 213, 273, 323, 373, 425,
      425, 373, 323, 273, 213, 135, 4, 2048,
    } ;
  register int DQL;
  
  /* RECONST and ADDA */
  DQL = (qtab[*I] + (*Y >> 2)) & 4095;
  
  /* ANTILOG */
  *DQ   = ((*I & (1 << 3)) * (1 << 11)) +  (DQL & (1 << 11) ? 0 :
	  (((1 << 7) + (DQL & 127)) << 7) >> (14 - ((DQL >> 7) & 15)));
  

}


/*****************************************************************
  C function definition of model diff_signal
*****************************************************************/
void dc_diff_signal_0 ( SL,SE,
                        D
                        )
register int *SL;
register int *SE;
register int *D;
{

  		
  /* SUBTA */
  *SL  = *SL & (1 << 13) ? 49152 | *SL : *SL;
  *SE  = *SE & (1 << 14) ? 32768 | *SE : *SE;
  *D = (*SL + 65536 - *SE) & 65535;


}


/*****************************************************************
  C function definition of model speed_control
*****************************************************************/
void dc_speed_control_0 ( L,Y,TR,TDP,
                          AL,
                          DMS,DML,AP
                          )
register int *L;
register int *Y;
register int *TR;
register int *TDP;
register int *AL;
register int *DMS;
register int *DML;
register int *AP;
{

  static int F[] = { 0, 0, 0, 1, 1, 1, 3, 7 };
  register int FI, tmp ; 

  /* FUNTCF */
  
  FI = F[(*L >> 3 ? (15 - *L) : *L) & 7] ; 

  /* FILTA routine 
     Update of the short term average of F[l] */

  tmp = ( (FI<<9) + 8192 -  (*DMS)  ) & 8191 ; 
  tmp = (tmp >> 12) ? (tmp >> 5) + 3840 : (tmp >> 5) ;
   (*DMS)  = (tmp +  (*DMS) ) & 4095 ;  

  /* FILTB routine 
     Update of the long term average of F[l] */

  tmp = ( (FI<<11) + 32768 -  (*DML)  ) & 32767 ; 
  tmp = (tmp >> 14) ? (tmp >> 7) + 16128 : (tmp >> 7) ;
   (*DML)  = (tmp +  (*DML) ) & 16383 ; 

  /* SUBTC routine */
  /* Compute magnitude of the difference of short and long term functions
   of quantizer output sequence and then perform threshold comparison
   for quantizing speed control parameter 
  */

  tmp = ( ( (*DMS)  << 2) + 32768  -  (*DML)  ) & 32767  ;
  tmp = (tmp >> 14) ? (32768 - tmp) & 16383 : tmp ; 

  /* FI is now the speed control parameter update */
  /* 1536 d = 0011000000000 for SM 13 (3.-9) is 3 */

  FI = ( (*Y >= 1536) && (tmp < ( (*DML)  >> 3) ) && ((*TDP & 0x1) == 0) ) 
       ? 0 : 1;

 /* FILTC : low pass filter of speed control parameter */
 
  tmp = ((FI << 9) + 2048 -  (*AP) ) & 2047 ; 
  tmp = (tmp >> 10) ? (tmp >> 4) & 896 : (tmp >> 4) ; 
  tmp = (tmp +  (*AP) ) & 1023 ; 

 /* TRIGA: Speed control trigger funcion */

   (*AP)  = ((*TR & 0x1) == 1) ?  256 : tmp ; 

  /* G.721 recommendation p.250 (LIMA Function) */
  /* 256 = 0100000000 bin = 1 for a 10SM 1.-8 value */

  *AL = ( (*AP)  > 255) ? 64 :  (*AP)  >> 2; 


}


/*****************************************************************
  C function definition of model adpt_quant
*****************************************************************/
void dc_adpt_quant_0 ( D,Y,
                       I
                       )
register int *D;
register int *Y;
register int *I;
{

  register int DS, DLN, EXP;
 
  /* LOG */
  DS = *D & (1 << 15);
  DLN = DS ? (65536 - *D) & 32767 : *D;
  for (EXP = 1; DLN >> EXP; EXP++)
    ;
  EXP--;
  DLN = (EXP * (1 << 7)) + (((DLN * (1 << 7)) >> EXP) & 127);
  
  /* SUBTB */
  DLN = (DLN + 4096 - (*Y >> 2)) & 4095;
  
  /* QUAN */
  if (DLN > 3971)
    *I = DS ? 0xE : 0x1;
  else 
    if (DLN > 2047) 
      *I = 0xF;
    else 
      if (DLN > 399)
	*I = DS ? 0x8 : 0x7;
      else 
	if (DLN > 348)
	  *I = DS ? 0x9 : 0x6;
	else 
	  if (DLN > 299)
	    *I = DS ? 0xA : 0x5;	
	  else 
	    if (DLN > 245)
	      *I = DS ? 0xB : 0x4;
	    else 
	      if (DLN > 177)
		*I = DS ? 0xC : 0x3;
	      else 
		if (DLN > 79)
		  *I = DS ? 0xD : 0x2;
		else
		  *I = DS ? 0xE : 0x1;
  

}


/*****************************************************************
  C function definition of model tone_detector
*****************************************************************/
void dc_tone_detector_0 ( DQ,A_2,YL,
                          TR,T_DP,
                          t_dr,LAST_TR
                          )
register int *DQ;
register int *A_2;
register int *YL;
register int *TR;
register int *T_DP;
register int *t_dr;
register int *LAST_TR;
{

  register int tmp ; 
  register int t_d ; 

  /* partial band signal detection */
  *T_DP = ( (*A_2 > 32769) && (*A_2 < 53761) ) ? 1 : 0 ; 
  
  /* take last  (*t_dr)  */
  t_d =  (*t_dr)  ;
  
  /* calcutale new  (*t_dr)  */
  /* TRIGB Function */
   (*t_dr)  = ( (*LAST_TR)  == 0) ? *T_DP : 0 ; 
  
   (*LAST_TR)  = *YL >> 15 ; /*  (*LAST_TR)  is used here as a temporary variable */
  
  tmp = ( (*LAST_TR)  > 8) ? 
    31 << 9 : (32 + (( (*LAST_TR)  << 5) & 31)) <<  (*LAST_TR)  ; 
  
   (*LAST_TR)  = *TR = ( ((*DQ & 16383) > (tmp + (tmp >> 1) ) >> 1) 
		   && (t_d == 1) )  ?  
		     1 : 0;

}


/*****************************************************************
  C function definition of model adpt_predict
*****************************************************************/
void dc_adpt_predict_0 ( DQ,T,
                         S_E,A_2,
                         DQ2,DQ3,DQ4,DQ5,DQ6,DQ7,PK1,
                         PK2,SR2,A1,A2,B,SE,SEZ
                         )
register int *DQ;
register int *T;
register int *S_E;
register int *A_2;
int *DQ2;
int *DQ3;
int *DQ4;
int *DQ5;
int *DQ6;
int *DQ7;
int *PK1;
int *PK2;
int *SR2;
int *A1;
int *A2;
int *B;
int *SE;
int *SEZ;
{

  register int DQS, DQI, DQSEZ, PK0 ; 
  register int SR1;
  register int A1S, AP;	
  register int A2R ;	
  register int WA1, WA2;
  register int MAG, EXP, MANT ; 
  int BP[6]; 
  
  /* ADDC */
  DQS = *DQ >> 14;
  DQI = DQS == 0 ? *DQ : (65536 - (*DQ & 16383)) & 65535;
  MAG = (( (*SEZ)  >> 14) == 0) ?  (*SEZ)  : (1 << 15) +  (*SEZ) ;
  DQSEZ = (DQI + MAG) & 65535;
  PK0 = DQSEZ >> 15;
  WA2 = DQSEZ == 0 ? 1 : 0;
  
  /* ADDB */
  DQI = DQS == 0 ? *DQ : (65536 - (*DQ & 16383)) & 65535;
  MAG = (( (*SE)  >> 14) == 0) ?  (*SE)  : (1 << 15) +  (*SE) ;
  DQSEZ = (DQI + MAG) & 65535;
  
  /* FLOATB */
  MAG = ((DQSEZ >> 15) == 0) ? DQSEZ : (65536 - DQSEZ) & 32767;
  for (EXP = 0; (MAG >> EXP) != 0; EXP++)
    ;
  MANT = MAG == 0 ? 1 << 5 : (MAG << 6) >> EXP;
  SR1 = ( (DQSEZ >> 15) << 10)  + (EXP << 6) + MANT;
  
  /* UPA2 */
  WA1 = PK0 ^  (*PK1) ;
  MAG = (PK0 ^  (*PK2) ) == 0 ? 16384 : 114688;
  A1S =  (*A1)  >> 15;
  if (A1S == 0)
    EXP =  (*A1)  <= 8191 ?  (*A1)  << 2 : 8191 << 2;
  else
    EXP =  (*A1)  >= 57345 ? ( (*A1)  << 2) & 131071 : 24577 << 2;
  EXP = WA1 == 1 ? EXP : (131072 - EXP) & 131071;
  MAG = (MAG + EXP) & 131071;
  EXP = WA2 == 1 ? 0 :
    ( (MAG >> 16) == 0)  ? MAG >> 7 : (MAG >> 7) + 64512;
  MANT = ( (*A2)  >> 15) == 0 ? (65536 - ( (*A2)  >> 7)) & 65535 :
    (65536 - (( (*A2)  >> 7) + 65024)) & 65535;
  EXP = (EXP + MANT) & 65535;
  EXP = ( (*A2)  + EXP) & 65535;
  
  /* LIMC */
  AP = 32768 <= EXP && EXP <= 53248 ? 53248 :
    12288 <= EXP && EXP <= 32767 ? 12288 : EXP;
  
  /* TRIGB */
  A2R = *T == 0 ? AP : 0;
  
  /* UPA1 */
  EXP = WA2 == 1 ? 0 : (WA1 == 0 ? 192 : 65344);
  MANT = A1S == 0 ? (65536 - ( (*A1)  >> 8)) & 65535 :
    (65536 - (( (*A1)  >> 8) + 65280)) & 65535;
  EXP = (EXP + MANT) & 65535;
  EXP = ( (*A1)  + EXP) & 65535;
  
  /* FMULT */
  WA2 = fmult(A2R,  (*SR2) ) ; 
 
  /* LIMD */
  MAG = (15360 + 65536 - AP) & 65535;
   (*A1)  = (AP + 65536 - 15360) & 65535;
  AP = 32768 <= EXP && EXP <=  (*A1)  ?  (*A1)  :
    MAG <= EXP && EXP <= 32767 ? MAG : EXP;
  
  /* TRIGB */
   (*A1)  = *T == 0 ? AP : 0;
  
  /* FMULT */
  WA1 = fmult( (*A1) , SR1);
  
  /* FLOATA */
  MAG = *DQ & 16383;
  for (EXP = 0; (MAG >> EXP) != 0; EXP++)
    ;
  MANT = MAG == 0 ? 1 << 5 : (MAG << 6) >> EXP;
  DQSEZ = (DQS << 10) + (EXP << 6) + MANT;
  
  /* XOR */
  BP[0] = DQS ^ ( (*DQ2)  >> 10);
  BP[1] = DQS ^ ( (*DQ3)  >> 10);
  BP[2] = DQS ^ ( (*DQ4)  >> 10);
  BP[3] = DQS ^ ( (*DQ5)  >> 10);
  BP[4] = DQS ^ ( (*DQ6)  >> 10);
  BP[5] = DQS ^ ( (*DQ7)  >> 10);
  
  /* UPB */
  MANT = *DQ & 16383;
  for (EXP = 0; EXP < 6; EXP++)
    {
      DQS = MANT == 0 ? 0 : (BP[EXP] == 0 ? 128 : 65408);
      MAG = B[EXP] >> 15;
      DQS += MAG == 0 ? (65536 - (B[EXP] >> 8)) & 65535 :
	(65536 - ((B[EXP] >> 8) + 65280)) & 65535;
      DQS &= 65535;
      BP[EXP] = (B[EXP] + DQS) & 65535;
    }
  
  /* TRIGB */
  if (*T != 0)
    for (EXP = 0; EXP < 6; EXP++)
      BP[EXP] = 0 ;
  
  /* FMULT */
  DQI  = fmult(BP[0], DQSEZ);
  MAG  = fmult(BP[1],  (*DQ2) );
  MANT = fmult(BP[2],  (*DQ3) );
  A1S  = fmult(BP[3],  (*DQ4) );
  AP   = fmult(BP[4],  (*DQ5) );
  EXP  = fmult(BP[5],  (*DQ6) );
  
  /* ACCUM */
  DQS = (((((((((DQI + MAG) & 65535) + MANT) & 65535)
	      + A1S) & 65535) + AP) & 65535) + EXP) & 65535;
   (*SEZ)  = DQS >> 1;
  *S_E =  (*SE)  = ( (((DQS + WA2) & 65535) + WA1) & 65535 )>> 1;
  
  /* STATE update */
   (*PK2)  =  (*PK1) ;
   (*PK1)  = PK0;
   (*SR2)  = SR1;
  *A_2 =  (*A2)  = A2R;

  for (EXP = 0; EXP < 6; EXP++)
    B[EXP] = BP[EXP];

   (*DQ7)  =  (*DQ6) ;
   (*DQ6)  =  (*DQ5) ;
   (*DQ5)  =  (*DQ4) ;
   (*DQ4)  =  (*DQ3) ;
   (*DQ3)  =  (*DQ2) ;
   (*DQ2)  = DQSEZ;
  	

}


/*****************************************************************
  C function definition of model add
*****************************************************************/
void dc_add_0 ( AddIn1,AddIn2,
                AddOut
                )
register int *AddIn1;
register int *AddIn2;
register int *AddOut;
{

/* 15 SM auf 16 TC */

    *AddIn1 = (*AddIn1 & (1 << 14)) ? *AddIn1 == (1 << 14) ? 0: 
              (((*AddIn1 ^ 0x3FFF) + 0x1) & 0x3FFF) + 0xC000 : *AddIn1 ; 

/* 15 TC auf 16 TC */

    *AddIn2 = (*AddIn2 & (1 << 14)) ? 0x8000 + *AddIn2 : *AddIn2 ; 

/* perform add operation at 16 TC */

    *AddOut  = (*AddIn1 + *AddIn2) & 0xffff;

    /* Output conversions */

    *AddOut = (*AddOut & 0x8000) ? 0xFFFF0000 | *AddOut : *AddOut  ; 


}


/*****************************************************************
  C function definition of model coding_adj
*****************************************************************/
void dc_coding_adj_0 ( L,SP,SE,Y,
                       SD
                       )
register int *L;
register int *SP;
register int *SE;
register int *Y;
register int *SD;
{

	*SD = *SP & 0x7FFF;

}


int dc_shared_int[17];
/* Definitions of signal arcs */
int *signal1 = dc_shared_int + 4;
int signal2[2] = {0};
int *signal3 = dc_shared_int + 4;
int signal4[2] = {0};
int *signal5 = dc_shared_int + 15;
int *signal6 = dc_shared_int + 7;
int *signal7 = dc_shared_int + 11;
int *signal8 = dc_shared_int + 10;
int *signal9 = dc_shared_int + 1;
int *signal10 = dc_shared_int + 4;
int *signal11 = dc_shared_int + 13;
int *signal12 = dc_shared_int + 14;
int *signal13 = dc_shared_int + 5;
int *signal14 = dc_shared_int + 3;
int *signal15 = dc_shared_int + 12;
int *signal16 = dc_shared_int + 6;
int *signal17 = dc_shared_int + 11;
int *signal18 = dc_shared_int + 2;
int *signal19 = dc_shared_int;
int signal20[2] = {0};
int *signal21 = dc_shared_int + 8;
int *signal22 = dc_shared_int + 10;
int signal23[2] = {0};
int *signal24 = dc_shared_int + 13;
int *signal25 = dc_shared_int + 8;
int signal26[2] = {0};
int signal27[2] = {0};
int *signal28 = dc_shared_int + 4;
int *signal29 = dc_shared_int + 15;
int *signal30 = dc_shared_int + 16;
int signal31[2] = {0};
int signal32[2] = {0};
int *signal33 = dc_shared_int + 8;
int *signal34 = dc_shared_int + 10;
int *signal35 = dc_shared_int + 14;
int *signal36 = dc_shared_int + 11;
int *signal37 = dc_shared_int + 9;
int *signal38 = dc_shared_int + 16;
int *signal39 = dc_shared_int + 16;
int *signal40 = dc_shared_int + 8;
int *signal41 = dc_shared_int + 7;
int *signal42 = dc_shared_int;
int *signal43 = dc_shared_int + 8;
int *signal44 = dc_shared_int + 7;
int *signal45 = dc_shared_int + 16;



main()
{
 long dc_INIT;

 run56k_start();

 for( dc_INIT = 0; dc_INIT < 10; dc_INIT++ ) {

   dc_adpt_predict_0 ( signal4,signal2,
                       signal44,signal45,
                       &dc_DQ2_23,&dc_DQ3_23,&dc_DQ4_23,
                       &dc_DQ5_23,&dc_DQ6_23,&dc_DQ7_23,
                       &dc_PK1_23,&dc_PK2_23,&dc_SR2_23,
                       &dc_A1_23,&dc_A2_23,dc_B_23,&dc_SE_23,
                       &dc_SEZ_23
                       );

   dc_adpt_predict_0 ( signal20,signal23,
                       signal36,signal37,
                       &dc_DQ2_17,&dc_DQ3_17,&dc_DQ4_17,
                       &dc_DQ5_17,&dc_DQ6_17,&dc_DQ7_17,
                       &dc_PK1_17,&dc_PK2_17,&dc_SR2_17,
                       &dc_A1_17,&dc_A2_17,dc_B_17,&dc_SE_17,
                       &dc_SEZ_17
                       );

   dc_fork_0 ( signal36,
               signal12,signal13,
               1
               );

   dc_fork_1 ( signal31,
               signal17,signal18,signal19,
               1
               );

   dc_fork_1 ( signal26,
               signal14,signal15,signal16,
               1
               );

   dc_const_int_0 ( signal25,
                    dc_ConstantValue_9
                    );

   dc_diff_signal_0 ( signal25,signal44,
                      signal29
                      );

   dc_adpt_quant_0 ( signal29,signal17,
                     signal33
                     );

   dc_fork_2 ( signal33,
               signal5,signal6,signal7,signal8,signal9,
               signal10,signal11,
               1
               );

   dc_iadpt_quant_0 ( signal10,signal19,
                      signal40
                      );

   dc_fork_0 ( signal40,
               signal3,signal4 + 1,
               1
               );

   dc_tone_detector_0 ( signal3,signal45,signal32,
                        signal42,signal43,
                        &dc_t_dr_22,&dc_LAST_TR_22
                        );

   dc_fork_0 ( signal42,
               signal1,signal2 + 1,
               1
               );

   dc_speed_control_0 ( signal9,signal18,signal1,signal43,
                        signal39,
                        &dc_DMS_19,&dc_DML_19,&dc_AP_19
                        );

   dc_scale_factor_0 ( signal8,signal39,
                       signal31 + 1,signal32 + 1,
                       &dc_Y_L_14,&dc_LAST_Y_14
                       );

   dc_iadpt_quant_0 ( signal6,signal14,
                      signal28
                      );

   dc_fork_1 ( signal28,
               signal20 + 1,signal21,signal22,
               1
               );

   dc_add_0 ( signal22,signal12,
              signal38
              );

   dc_coding_adj_0 ( signal11,signal38,signal13,signal16,
                     signal41
                     );

   dc_tone_detector_0 ( signal21,signal37,signal27,
                        signal34,signal35,
                        &dc_t_dr_16,&dc_LAST_TR_16
                        );

   dc_fork_0 ( signal34,
               signal23 + 1,signal24,
               1
               );

   dc_speed_control_0 ( signal7,signal15,signal24,signal35,
                        signal30,
                        &dc_DMS_13,&dc_DML_13,&dc_AP_13
                        );

   dc_scale_factor_0 ( signal5,signal30,
                       signal26 + 1,signal27 + 1,
                       &dc_Y_L_10,&dc_LAST_Y_10
                       );

   *(signal2 + 0) = *(signal2 + 1);
   *(signal4 + 0) = *(signal4 + 1);
   *(signal20 + 0) = *(signal20 + 1);
   *(signal23 + 0) = *(signal23 + 1);
   *(signal26 + 0) = *(signal26 + 1);
   *(signal27 + 0) = *(signal27 + 1);
   *(signal31 + 0) = *(signal31 + 1);
   *(signal32 + 0) = *(signal32 + 1);
 }
 run56k_end();

} 
