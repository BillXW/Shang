


Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 1



1                                        ;
2                                        ; This program originally available on the Motorola DSP bulletin board.
3                                        ; It is provided under a DISCLAMER OF WARRANTY available from
4                                        ; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
5                                        ; 
6                                        ;**************************************************************************
7                                        ;
8                                        ;   ADPCM.ASM       Full-Duplex 32-kbit/s CCITT ADPCM Algorithm
9                                        ;
10                                       ; Version 1.0 - 1/27/89
11                                       ;
12                                       ; This program implements the algorithm defined in CCITT Recommendation
13                                       ; G.721: "32 kbit/s Adaptive Differential Pulse Code Modulation" dated
14                                       ; August 1986. This version passes all of the mu-law and A-law test
15                                       ; sequences as defined in Appendix II of Recommendation G.721.
16                                       ;
17                                       ; Please refer to the file ADPCM.HLP for further information about
18                                       ; this program.
19                                       ;
20                                       ;**************************************************************************
21     
22                                                 OPT     SO,CC,CEX
23                                                 PAGE    132,66,3,3
24     
25        000040                         START     EQU     $0040
26     
27        X:0000                                   ORG     X:$0000
28     
29                                       ;******************** Encoder variables ***********************************
30                                       ;   I = siii 0000 | 0000 0000 | 0000 0000 (ADPCM format)
31        X:0000                         I_T       DS      1                                 ;ADPCM codeword
32                                       ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
33        X:0001                         DQ_T      DS      1                                 ;Quantized difference signal
34                                       ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
35        X:0002                         Y_T       DS      1                                 ;Quantizer scale factor
36                                       ;   AP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
37        X:0003                         AP_T      DS      1                                 ;Unlimited speed control parameter
38                                       ;   AL = 0i.ff ffff | 0000 0000 | 0000 0000  (7SM)
39        X:0004                         AL_T      DS      1                                 ;Limited speed control parameter
40     
41                                       ;******************** Decoder variables ***********************************
42        X:0005                         I_R       DS      1                                 ;ADPCM codeword
43        X:0006                         DQ_R      DS      1                                 ;Quantized difference signal
44        X:0007                         Y_R       DS      1                                 ;Quantizer scale factor
45        X:0008                         AP_R      DS      1                                 ;Unlimited speed control parameter
46        X:0009                         AL_R      DS      1                                 ;Limited speed control parameter
47                                       ;   SP = psss qqqq | 0000 0000 | 0000 0000 (PCM log format)
48        X:000A                         SP_R      DS      1                                 ;PCM reconstructed signal
49     
50                                       ;******************** Temporary variables *********************************
51                                       ;   IMAG = 0iii. 0000 | 0000 0000 | 0000 0000
52        X:000B                         IMAG      DS      1                                 ;|I|
53                                       ;   PKS1 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
54        X:000C                         PKS1      DS      1                                 ;XOR of  PK0 & PK1
55                                       ;   PKS2 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
56        X:000D                         PKS2      DS      1                                 ;XOR of  PK0 & PK2






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 2



57        X:000E                         DATAPTR_T DS      1                                 ;Transmit data buffer pointer
58        X:000F                         DATAPTR_R DS      1                                 ;Receive data buffer pointer
59     
60     
61                                       ;******************** Table for quantizing DLN ****************************
62                                       ; Used in QUAN routine
63     
64        X:0010                         QUANTAB   DS      8
65     
66                                       ;******************** Table for unquantizing I ****************************
67                                       ; Used in RECONST
68     
69        X:0018                         IQUANTAB  DS      8
70     
71                                       ;******************** W(I) lookup table ***********************************
72                                       ; Used in FUNCTW routine
73     
74        X:0020                         WIBASE    DS      8
75     
76                                       ;******************** Table used in COMPRESS ******************************
77     
78        X:0028                         TAB       DS      8
79     
80                                       ;******************** Constants used by FMULT *****************************
81     
82        X:0030                         CONST     DS      6
83     
84                                       ;******************** Encoder data buffer *********************************
85                                       ; DQn (11FL) stored separately as exponent, mantissa, and sign
86                                       ;    DQnEXP = 0000 0000 | 0000 0000 | 0000 eeee
87                                       ;    DQnMANT = 01mm mmm0 | 0000 0000 | 0000 0000
88                                       ;    DQnS = sXXX XXXX | XXXX XXXX | 0000 0000
89                                       ; SRn in same format
90        X:0040                         DATA_T    DSM     24                                ;24 word modulo buffer for data,
91                                                                                           ; R2 is used as pointer, DATAPTR_T
92                                                                                           ; points to start of buffer (DQ1EXP)
93                                                                                           ; at beginning of cycle
94                                                                                           ;DQ1EXP,DQ1MANT,DQ1S
95                                                                                           ;DQ2EXP,DQ2MANT,DQ2S
96                                                                                           ;DQ3EXP,DQ3MANT,DQ3S
97                                                                                           ;DQ4EXP,DQ4MANT,DQ4S
98                                                                                           ;DQ5EXP,DQ5MANT,DQ5S
99                                                                                           ;DQ6EXP,DQ6MANT,DQ6S
100                                                                                          ;SR1EXP,SR1MANT,SR1S
101                                                                                          ;SR2EXP,SR2MANT,SR2S
102    
103                                      ;******************** Encoder partial product buffer **********************
104                                      ;   WBn = siii iiii | iiii iii.f | 0000 0000  (16TC)
105                                      ;   WAn in same format
106       X:0058                         PP_T      DSM     8                                 ;8 word modulo buffer for partial
107                                                                                          ; products, R1 is used as pointer
108                                                                                          ;WB1
109                                                                                          ;WB2
110                                                                                          ;WB3
111                                                                                          ;WB4
112                                                                                          ;WB5






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 3



113                                                                                          ;WB6
114                                                                                          ;WA1
115                                                                                          ;WA2
116    
117                                      ;******************** Decoder data buffer *********************************
118       X:0060                         DATA_R    DSM     24                                ;24 word modulo buffer for data
119                                                                                          ; (same format as DATA_T)
120    
121                                      ;******************** Decoder partial product buffer **********************
122       X:0078                         PP_R      DSM     8                                 ;8 word modulo buffer for partial produ
cts
123                                                                                          ; (same format as PP_T)
124    
125    
126       Y:0000                                   ORG     Y:$0000
127                                      ;******************** Encoder variables ***********************************
128                                      ;   SE = siii iiii | iiii iii.0 | 0000 0000  (15TC)
129       Y:0000                         SE_T      DS      1                                 ;Signal estimate
130                                      ;   SEZ = siii iiii | iiii iii.0 | 0000 0000 (15TC)
131       Y:0001                         SEZ_T     DS      1                                 ;Partial signal estimate
132                                      ;   SR = siii iiii | iiii iiii. | 0000 0000  (16TC)
133       Y:0002                         SR_T      DS      1                                 ;Reconstructed signal
134                                      ;   PK0 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
135       Y:0003                         PK0_T     DS      1                                 ;Sign of DQ + SEZ
136                                      ;   PK1 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
137       Y:0004                         PK1_T     DS      1                                 ;Delayed sign of DQ + SEZ
138                                      ;   PK2 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
139       Y:0005                         PK2_T     DS      1                                 ;Delayed sign of DQ + SEZ
140                                      ;   DMS = 0iii. ffff | ffff f000 | 0000 0000  (12SM)
141       Y:0006                         DMS_T     DS      1                                 ;Short term average of F(I)
142                                      ;   DML = 0iii. ffff | ffff fff0 | 0000 0000  (14SM)
143       Y:0007                         DML_T     DS      1                                 ;Long term average of F(I)
144                                      ;   TDP = i000 0000 | 0000 0000 | 0000 0000  (1TC)
145       Y:0008                         TDP_T     DS      1                                 ;Tone detect
146                                      ;   TD = i000 0000 | 0000 0000 | 0000 0000  (1TC)
147       Y:0009                         TD_T      DS      1                                 ;Delayed tone detect
148                                      ;   YU =  0iii i.fff | ffff ff00 | 0000 0000  (13SM)
149       Y:000A                         YU_T      DS      1                                 ;Fast quantizer scale factor
150                                      ;   YL =  0iii i.fff | ffff ffff | ffff 0000  (19SM)
151       Y:000B                         YL_T      DS      1                                 ;Slow quantizer scale factor
152                                      ;   SIGPK = i000 0000 | 0000 0000 | 0000 0000  (1TC)
153       Y:000C                         SIGPK_T   DS      1                                 ;Sgn[p(k)] flag
154                                      ;   A2P = si.ff ffff | ffff ffff | 0000 0000 (16TC)
155       Y:000D                         A2P_T     DS      1                                 ;Second order predictor coef
156                                      ;   TR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
157       Y:000E                         TR_T      DS      1                                 ;Transition detect
158    
159                                      ;******************** Decoder variables ***********************************
160       Y:000F                         SE_R      DS      1                                 ;Signal estimate
161       Y:0010                         SEZ_R     DS      1                                 ;Partial signal estimate
162       Y:0011                         SR_R      DS      1                                 ;Reconstructed signal
163       Y:0012                         PK0_R     DS      1                                 ;Sign of DQ + SEZ
164       Y:0013                         PK1_R     DS      1                                 ;Delayed sign of DQ + SEZ
165       Y:0014                         PK2_R     DS      1                                 ;Delayed sign of DQ + SEZ
166       Y:0015                         DMS_R     DS      1                                 ;Short term average of F(I)
167       Y:0016                         DML_R     DS      1                                 ;Long term average of F(I)






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 4



168       Y:0017                         TDP_R     DS      1                                 ;Tone detect
169       Y:0018                         TD_R      DS      1                                 ;Delayed tone detect
170       Y:0019                         YU_R      DS      1                                 ;Fast quantizer scale factor
171       Y:001A                         YL_R      DS      1                                 ;Slow quantizer scale factor
172       Y:001B                         SIGPK_R   DS      1                                 ;Sgn[p(k)] flag
173       Y:001C                         A2P_R     DS      1                                 ;Second order predictor coef
174       Y:001D                         TR_R      DS      1                                 ;Transition detect
175    
176                                      ;******************** Temporary variables *********************************
177       Y:001E                         LAW       DS      1                                 ;Select A-law or mu-law
178       Y:001F                         DQMAG     DS      1                                 ;|DQ|
179    
180                                      ;******************** Shift constant lookup table *************************
181                                      ; Shift constants used for doing left or right shifts by multiplying by a
182                                      ; power of 2.  For right shift, some routines use R5 as a base and N5 as
183                                      ; and offset for lookup of shift constant.
184       Y:0020                         RSHFT     DS      24
185                                      LSHFT
186    
187                                      ;******************** Misc. constants *************************************
188       Y:0038                         CONST1    DS      3
189       Y:003B                         CONST4    DS      4
190       Y:003F                         CONST8    DS      9
191       Y:0048                         CONST17   DS      16
192    
193                                      ;******************** Encoder coef. buffer ********************************
194                                      ;   Bn = si.ff ffff | ffff ffff | 0000 0000 (16TC)
195                                      ;   An in same format
196       Y:0058                         COEF_T    DSM     8                                 ;8 word modulo buffer for coefs.,
197                                                                                          ; R6 is used as pointer
198                                                                                          ;B1
199                                                                                          ;B2
200                                                                                          ;B3
201                                                                                          ;B4
202                                                                                          ;B5
203                                                                                          ;B6
204                                                                                          ;A1
205                                                                                          ;A2
206    
207                                      ;******************** Decoder coef. buffer ********************************
208       Y:0060                         COEF_R    DSM     8                                 ;8 locations for coef. queue
209                                                                                          ; (same format as COEF_T)
210    



















Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 5



212    
213       P:0000                                   ORG     P:$0000
214       P:0000 0C0040  [4 -        4]            JMP     START
215    
216       P:0040                                   ORG     P:START
217    
218                                      Fmain
219       P:0040 200013  [2 -        6]            CLR     A
220       P:0041 0506BA  [2 -        8]            MOVEC             #$06,OMR                ;Enable internal ROM tables
221       P:0042 08CE3E  [4 -       12]            MOVEP             A,X:$FFFE               ;Set BCR for 0 wait states
222                                      ;       JSR     INIT
223    
224                                      ;**************************************************************************
225                                      ;
226                                      ;   Encoder
227                                      ;
228                                      ;**************************************************************************
229    
230       P:0043 315800  [2 -       14]  ENCODE    MOVE              #PP_T,R1                ;Set partial product ptr to WB1
231       P:0044 628E00  [2 -       16]            MOVE              X:DATAPTR_T,R2          ;Set data pointer to DQ1EXP
232       P:0045 365800  [2 -       18]            MOVE              #COEF_T,R6              ;Set coef pointer to B1
233       P:0046 373800  [2 -       20]            MOVE              #CONST1,R7              ;Set pointer to misc constants
234    
235                                      ;**************************************************************************
236                                      ;       FMULT
237                                      ;
238                                      ; Multiply predictor coefficients with corresponding
239                                      ;   quantized difference signal or reconstructed signal
240                                      ;
241                                      ;   Data (DQn or SRn) is stored in 11FL format (separate),
242                                      ;   & coefficient (Bn or An) is stored in 16TC format.
243                                      ;
244                                      ; Computes  [An(k-1) * SR(k-n)] or [Bn(k-1) * DQ(k-n)]
245                                      ;
246                                      ; Flow Description:
247                                      ;   1. Convert 16TC An to 13SM AnMAG
248                                      ;   2. Convert 13SM AnMAG to 10FL (AnEXP and AnMANT)
249                                      ;   3. Add SRnEXP to AnEXP to get WAnEXP (5-bits)
250                                      ;   4. Multiply SRnMANT with AnMANT, add '48', and truncate
251                                      ;       to 8-bits to get WAnMANT
252                                      ;   5. Convert 13FL (WAnEXP & WAnMANT) to 15SM WAnMAG
253                                      ;   6. XOR AnS with SRnS to find WAnS
254                                      ;   7. Convert 16SM (WAnMAG & WAnS) to 16TC WAn
255                                      ;
256                                      ; Input:
257                                      ;   SRn = (11FL)
258                                      ;    SRnEXP = X:(R2) = 0000 0000 | 0000 0000 | 0000 eeee
259                                      ;    SRnMANT = X:(R2+1) = 01mm mmm0 | 0000 0000 | 0000 0000
260                                      ;    SRnS = X:(R2+2) = sXXX XXXX | XXXX XXXX | 0000 0000
261                                      ;       (DQ in same format as SR)
262                                      ;
263                                      ;   An = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
264                                      ;       (Bn in same format as An)
265                                      ;
266                                      ; Output:
267                                      ;   WAn = X:(R1) = siii iiii | iiii iii.f | 0000 0000  (16TC)






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 6



268                                      ;       (WBn in same format as WAn)
269                                      ;
270                                      ;**************************************************************************
271    
272       P:0047 303000  [2 -       22]            MOVE              #CONST,R0               ;Set pointer to FMULT constants
273       P:0048 270000  [2 -       24]            MOVE              #0,Y1
274       P:0049 060880  [6 -       30]            DO      #8,ACCUM_T                        ;Execute mult 8 times
                 000076
275    
276                                      ; 1. Convert 16TC An to 13SM AnMAG
277       P:004B C6D800  [2 -       32]            MOVE              X:(R0)+,X1  Y:(R6),A    ;Get An and mask KF1
278       P:004C 45D866  [2 -       34]            AND     X1,A      X:(R0)+,X1              ;Truncate An to 13 bits (An>>2),
279                                                                                          ; get mask KF2
280       P:004D 340D26  [2 -       36]            ABS     A         #$000D,R4               ;Find AnMAG, load
281                                                                                          ; exponent bias (13) into R4
282       P:004E 257E66  [2 -       38]            AND     X1,A      #<$7E,X1                ;Truncate any ovrflw, get mask
283                                      ;   A1 = 0i.ff ffff | ffff ff00 | 0000 0000 (A2=A0=0)
284    
285                                      ; 2. Convert 13SM AnMAG to 10FL (AnEXP and AnMANT)
286       P:004F 0E2053  [4 -       42]            JNE     <NORMAN_T                         ;Test AnMAG
287       P:0050 2E4000  [2 -       44]            MOVE              #<$40,A                 ;If AnMAG=0, set AnMANT=1<<5,
288       P:0051 340000  [2 -       46]            MOVE              #0,R4                   ; and AnEXP=0
289       P:0052 0C005F  [4 -       50]            JMP     <CONTIN_T
290       P:0053 01DC15  [2 -       52]  NORMAN_T  NORM    R4,A                              ;If AnMAG!=0 do NORM iteration
291       P:0054 01DC15  [2 -       54]            NORM    R4,A                              ; 12 times to find MSB
292       P:0055 01DC15  [2 -       56]            NORM    R4,A
293       P:0056 01DC15  [2 -       58]            NORM    R4,A
294       P:0057 01DC15  [2 -       60]            NORM    R4,A
295       P:0058 01DC15  [2 -       62]            NORM    R4,A
296       P:0059 01DC15  [2 -       64]            NORM    R4,A
297       P:005A 01DC15  [2 -       66]            NORM    R4,A
298       P:005B 01DC15  [2 -       68]            NORM    R4,A
299       P:005C 01DC15  [2 -       70]            NORM    R4,A
300       P:005D 01DC15  [2 -       72]            NORM    R4,A
301       P:005E 01DC15  [2 -       74]            NORM    R4,A
302                                      ;   A1 = 01?? ???? | ???? ??00 | 0000 0000 = AnMANT
303                                      ;   R4 = 0000 0000 | 0000 eeee = AnEXP
304       P:005F 228F66  [2 -       76]  CONTIN_T  AND     X1,A      R4,B                    ;Truncate AnMANT to 6 bits,
305                                                                                          ; move AnEXP to B
306                                      ;   A1 = 01mm mmm0 | 0000 0000 | 0000 0000 (A2=A0=0)
307                                      ;   B1 = 0000 0000 | 0000 0000 | 0000 eeee (B2=B0=0)
308    
309                                      ; 3. Add SRnEXP to AnEXP to get WAnEXP (5-bits)
310       P:0060 149A00  [2 -       78]            MOVE              X:(R2)+,X1  A,Y0        ;Get SRnEXP
311       P:0061 45DA68  [2 -       80]            ADD     X1,B      X:(R2)+,X1              ;Find WAnEXP=SRnEXP+AnEXP,
312                                                                                          ; get SRnMANT 
313                                      ;   B1 = 0000 0000 | 0000 0000 | 000e eeee (B2=B0=0)
314    
315                                      ; 4. Multiply SRnMANT with AnMANT, add '48', and truncate
316                                      ;       to 8-bits to get WAnMANT
317                                      ;   Y0 = 01mm mmm0 | 0000 0000 | 0000 0000
318                                      ;   X1 = 01mm mmm0 | 0000 0000 | 0000 0000
319       P:0062 44D8E0  [2 -       82]            MPY     Y0,X1,A   X:(R0)+,X0              ;Find WAnMANT, get '48' (KF3)
320                                      ;   A1 = 0mmm mmmm | mmmm m000 | 0000 0000 (A2=A0=0)
321                                      ;   X0 = 0000 0001 | 1000 0000 | 0000 0000 = '48'
322       P:0063 44D840  [2 -       84]            ADD     X0,A      X:(R0)+,X0              ;Add '48' to WAnMANT, get mask KF4






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 7



323       P:0064 44D846  [2 -       86]            AND     X0,A      X:(R0)+,X0              ;Truncate WAnMANT to 8 bits,
324                                                                                          ; get '26' (KF5)
325                                      ;   A1 = 0mmm mmmm | m000 0000 | 0000 0000 (A2=A0=0)
326    
327                                      ; 5. Convert 13FL (WAnEXP & WAnMANT) to 15SM WAnMAG
328                                      ;   X0 = 0000 0000 | 0000 0000 | 0001 1010 = '26'
329                                      ;   B1 = 0000 0000 | 0000 0000 | 000e eeee (B2=B0=0) 
330       P:0065 44D84C  [2 -       88]            SUB     X0,B      X:(R0)+,X0              ;Find shift offset (WAnEXP-26),
331                                                                                          ; get mask KF6
332       P:0066 0EA072  [4 -       92]            JEQ     <TRUNC_T                          ;If offset=26 no shift
333       P:0067 0EB06B  [4 -       96]            JMI     <RIGHT_T                          ;If offset<26 do right shift
334                                                                                          ;Else offset>26, do left shift
335       P:0068 06CD20  [4 -      100]            REP     B1                                ;Offset>26, shift WAnMANT
336       P:0069 200033  [2 -      102]            LSL     A                                 ; left up to 4 times
337       P:006A 0C0072  [4 -      106]            JMP     <TRUNC_T
338       P:006B 46F42E  [4 -      110]  RIGHT_T   ABS     B         #>$0F,Y0                ;Find |offset|, get '15'
                 00000F
339       P:006D 21BD5D  [2 -      112]            CMP     Y0,B      B1,N5                   ;Compare |offset| to '15',
340                                                                                          ; load offset for shift
341       P:006E 021070  [2 -      114]            TGE     Y1,A                              ;If |offset|>=15 WAnMAG=0
342       P:006F 218500  [2 -      116]            MOVE              A1,X1                   ;Move WAnMANT for shift
343       P:0070 4EED00  [4 -      120]            MOVE                          Y:(R5+N5),Y0 ;Lookup shift constant
344       P:0071 2000E0  [2 -      122]            MPY     Y0,X1,A                           ;Shift WAnMANT right up to 14 times
345                                      ;   A1 = ?mmm mmmm | mmmm mmmm | ???? ???? (A2=A0=0)
346       P:0072 F7DA46  [2 -      124]  TRUNC_T   AND     X0,A      X:(R2)+,X1  Y:(R6)+,B   ;Truncate WAnMAG to 15 bits,
347                                                                                          ; get SRnS & AnS
348                                      ;   A1 = 0iii iiii | iiii iii.f | 0000 0000 (A2=A0=0)
349       P:0073 218436  [2 -      126]            NEG     A         A1,X0                   ;Find -WAnMAG, save WAnMAG
350    
351                                      ; 6. XOR AnS with SRnS to find WAnS
352                                      ;   B1 = sXXX XXXX | XXXX XXXX | 0000 0000 (B2=sign ext, B0=0)
353                                      ;   X1 = sXXX XXXX | XXXX XXXX | 0000 0000
354       P:0074 30306B  [2 -      128]            EOR     X1,B      #CONST,R0               ;Find WAnS (in MSB of B),
355                                                                                          ; update pointer to constants
356    
357                                      ; 7. Convert 16SM (WAnMAG & WAnS) to 16TC WAn
358       P:0075 023040  [2 -      130]            TPL     X0,A                              ;If WAnS=0 use WAnMAG, else use -WAnMAG
359                                      ;   A1 = siii iiii | iiii iii.f | 0000 0000  (A2=sign ext, A0=0)
360       P:0076 545900  [2 -      132]            MOVE              A1,X:(R1)+              ;Save WAn
361    
362                                      ;**************************************************************************
363                                      ;       ACCUM
364                                      ;
365                                      ; Add predictor outputs to form the partial signal estimate
366                                      ;   and the signal estimate
367                                      ;
368                                      ; SEZ(k) = [B1(k-1) * DQ(k-1)] + ... + [B6(k-1) * DQ(k-6)]
369                                      ;        = WB1 + WB2 + ... + WB6
370                                      ;
371                                      ; SE(k) = SEZ(k) + [A1(k-1) * SR(k-1)] + [A2(k-1) * SR(k-2)]
372                                      ;       = SEZ + WA1 + WA2
373                                      ;
374                                      ; Inputs:
375                                      ;   WBn & WAn = X:(R1) = siii iiii | iiii iii.f | 0000 0000  (16TC)
376                                      ;
377                                      ; Outputs:






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 8



378                                      ;   SEZ = siii iiii | iiii iii.0 | 0000 0000  (15TC)
379                                      ;   SE = siii iiii | iiii iii.0 | 0000 0000  (15TC)
380                                      ;
381                                      ;**************************************************************************
382    
383       P:0077 56D900  [2 -      134]  ACCUM_T   MOVE              X:(R1)+,A               ;Get WB1
384       P:0078 44D900  [2 -      136]            MOVE              X:(R1)+,X0              ;Get WB2
385       P:0079 44D940  [2 -      138]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB1&WB2, get WB3
386       P:007A 44D940  [2 -      140]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB3, get WB4
387       P:007B 44D940  [2 -      142]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB4, get WB5
388       P:007C 44D940  [2 -      144]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB5, get WB6
389       P:007D 44D940  [2 -      146]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB6 to get SEZI, get WA1
390       P:007E 4DDF09  [2 -      148]            TFR     A,B                   Y:(R7)+,X1  ;Copy SEZI, get mask K1
391       P:007F 46836E  [2 -      150]            AND     X1,B      X:AP_T,Y0               ;Truncate SEZI, get AP
392       P:0080 44D940  [2 -      152]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WA1, get WA2
393       P:0081 5D0140  [2 -      154]            ADD     X0,A                  B1,Y:SEZ_T  ;Accumulate WA2 to get SEI, save SEZ
394       P:0082 242066  [2 -      156]            AND     X1,A      #<$20,X0                ;Truncate SEI, get '1'
395       P:0083 5C0051  [2 -      158]            TFR     Y0,A                  A1,Y:SE_T   ;Move AP, save SE
396    
397                                      ;**************************************************************************
398                                      ;       LIMA
399                                      ;
400                                      ; Limit speed control parameter
401                                      ;
402                                      ; AL(k) = 1        if AP(k-1) > 1
403                                      ;       = AP(k-1)  if AP(k-1) <= 1
404                                      ;
405                                      ; Inputs:
406                                      ;   AP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
407                                      ;
408                                      ; Outputs:
409                                      ;   AL = 0i.ff ffff | 0000 0000 | 0000 0000  (7SM)
410                                      ;
411                                      ;**************************************************************************
412    
413       P:0084 5F8B45  [2 -      160]            CMP     X0,A                  Y:YL_T,B    ;Test AP, get YL
414       P:0085 027040  [2 -      162]            TGT     X0,A                              ;If AP>'1' set AL='1'
415       P:0086 247F33  [2 -      164]            LSL     A         #<$7F,X0                ;Shift to align radix pt., get mask
416       P:0087 4CDF46  [2 -      166]            AND     X0,A                  Y:(R7)+,X0  ;Truncate AL (AP>>2), get mask K2
417    
418                                      ;**************************************************************************
419                                      ;       MIX
420                                      ;
421                                      ; Form linear combination of fast and slow quantizer
422                                      ;   scale factors
423                                      ;
424                                      ; Y(k) = AL(k) * YU(k-1) + [1 - AL(k)] * YL(k-1)
425                                      ;
426                                      ; Inputs:
427                                      ;   YL = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
428                                      ;   AL = 0i.ff ffff | 0000 0000 | 0000 0000  (7SM)
429                                      ;   YU = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
430                                      ;
431                                      ; Outputs:
432                                      ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
433                                      ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 9



434                                      ;**************************************************************************
435    
436       P:0088 12F04E  [4 -      170]            AND     X0,B      A,X0        Y:YU_T,A    ;Truncate YL (YL>>6), get YU
                 00000A
437       P:008A 133014  [4 -      174]            SUB     B,A       B,Y1        X0,X:AL_T   ;Find DIF=YU-YL, save YL, get AL
                 000004
438       P:008C 21CF26  [2 -      176]            ABS     A         A,B                     ;Find DIFM=|DIF|, save DIFS
439       P:008D 218600  [2 -      178]            MOVE              A1,Y0
440       P:008E 4CDFD0  [2 -      180]            MPY     X0,Y0,A               Y:(R7)+,X0  ;Find DIFM*AL, get mask K3
441       P:008F 200046  [2 -      182]            AND     X0,A                              ;Truncate to find PRODM=(DIFM*AL)>>6
442       P:0090 218436  [2 -      184]            NEG     A         A1,X0                   ;Find -PRODM, save PRODM
443       P:0091 20000B  [2 -      186]            TST     B                                 ;Check DIFS
444       P:0092 023040  [2 -      188]            TPL     X0,A                              ;If DIFS=0 PROD=PRODM,
445                                                                                          ; else PROD=-PRODM
446       P:0093 20EF32  [2 -      190]            ASL     A         Y1,B                    ;Line up radix point
447       P:0094 200070  [2 -      192]            ADD     Y1,A                              ;Find Y=PROD+(YL>>6)
448       P:0095 560200  [2 -      194]            MOVE              A,X:Y_T                 ;Save Y
449    
450                                      ;**************************************************************************
451                                      ;
452                                      ; Input PCM data (S) here. For simulation purposes the Input 
453                                      ; Word from File subroutine on the 56001 ADS board is used.
454                                      ;
455                                      ;**************************************************************************
456    
457       P:0096 240100  [2 -      196]            MOVE              #1,X0                   ;Input PCM word (S)
458       P:0097 0BF080  [6 -      202]            JSR     $E002
                 00E002
459    
460                                      ; EXPAND ELIMINATED !
461    
462                                      ;**************************************************************************
463                                      ;       SUBTA
464                                      ;
465                                      ; Compute difference signal by subtracting signal estimate
466                                      ;       from input signal
467                                      ;
468                                      ;   D(k) = SL(k) - SE(k)
469                                      ;
470                                      ; Inputs:
471                                      ;   SL = siii iiii | iiii ii.00 | 0000 0000  (14TC) 
472                                      ;   SE = siii iiii | iiii iii.0 | 0000 0000  (15TC)
473                                      ;
474                                      ; Output:
475                                      ;   D = siii iiii | iiii iiii. | 0000 0000  (16TC)
476                                      ;**************************************************************************
477    
478       P:0099 4DDF22  [2 -      204]  SUBTA_T   ASR     A                     Y:(R7)+,X1  ;Sign extend SL, get mask K6
479       P:009A 300E22  [2 -      206]            ASR     A         #$000E,R0               ;Sign extend SE again, get exp bias (14
)
480       P:009B 578214  [2 -      208]            SUB     B,A       X:Y_T,B                 ;Find D=SL-SE, get Y
481    
482                                      ;**************************************************************************
483                                      ;       LOG
484                                      ;
485                                      ; Convert difference signal from the linear to the log






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 10



486                                      ;   domain
487                                      ;
488                                      ; Input:
489                                      ;   D = siii iiii | iiii iiii. | 0000 0000  (16TC)
490                                      ;
491                                      ; Outputs:
492                                      ;   DL = 0iii i.fff | ffff 0000 | 0000 0000  (11SM)
493                                      ;   DS = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
494                                      ;
495                                      ;**************************************************************************
496    
497       P:009C 21C726  [2 -      210]            ABS     A         A,Y1                    ;Find DQM=|D|, save DS to Y1
498       P:009D 0E20A1  [4 -      214]            JNE     <NORMEXP_T                        ;Check for DQM=0
499       P:009E 205F13  [2 -      216]            CLR     A         (R7)+                   ;If DQM=0 set DL=0,
500       P:009F 4CE700  [2 -      218]            MOVE                          Y:(R7),X0   ; get mask K8,
501       P:00A0 0C00B4  [4 -      222]            JMP     <SUBTB_T                          ; and continue
502       P:00A1 01D815  [2 -      224]  NORMEXP_T NORM    R0,A                              ;If DQM!=0, do norm iteration
503       P:00A2 01D815  [2 -      226]            NORM    R0,A                              ; 14 times to find MSB of DQM
504       P:00A3 01D815  [2 -      228]            NORM    R0,A
505       P:00A4 01D815  [2 -      230]            NORM    R0,A
506       P:00A5 01D815  [2 -      232]            NORM    R0,A
507       P:00A6 01D815  [2 -      234]            NORM    R0,A
508       P:00A7 01D815  [2 -      236]            NORM    R0,A
509       P:00A8 01D815  [2 -      238]            NORM    R0,A
510       P:00A9 01D815  [2 -      240]            NORM    R0,A
511       P:00AA 01D815  [2 -      242]            NORM    R0,A
512       P:00AB 01D815  [2 -      244]            NORM    R0,A
513       P:00AC 01D815  [2 -      246]            NORM    R0,A
514       P:00AD 01D815  [2 -      248]            NORM    R0,A
515       P:00AE 01D815  [2 -      250]            NORM    R0,A
516                                      ;   A1 = 01?? ???? | ???? ???? | 0000 0000 = normalized DQM  (A2=A0=0)
517                                      ;   R0 = 0000 0000 | 0000 eeee = exponent of normalized DQM
518    
519                                      ;   Get rid of leading "1" in normalized DQM
520                                      ;   Truncate mantissa to 7 bits and combine with exponent
521       P:00AF 4CA566  [2 -      252]            AND     X1,A                  Y:LSHFT-19,X0 ;Truncate MANT, get EXP shift
522                                      ;   A1 = 00mm mmmm | m000 0000 | 0000 0000 (A2=A0=0)
523       P:00B0 220500  [2 -      254]            MOVE              R0,X1                   ;Move EXP to X1
524       P:00B1 14DFA0  [2 -      256]            MPY     X0,X1,A   A,X1        Y:(R7)+,Y0  ;Shift EXP<<19, save MANT to X1,
525                                                                                          ; get mask K7
526       P:00B2 210E00  [2 -      258]            MOVE              A0,A                    ;Move EXP to A1
527                                      ;   A1 = 0eee e000 | 0000 0000 | 0000 0000 (A2=A0=0)
528       P:00B3 4CE7E2  [2 -      260]            MAC     Y0,X1,A               Y:(R7),X0   ;Shift MANT>>3 & combine with EXP,
529                                                                                          ; get mask K8
530                                      ;   A1 = 0eee e.mmm | mmmm 0000 | 0000 0000  (A2=A0=0)
531                                      ;      = 0iii i.fff | ffff 0000 | 0000 0000  (A2=A0=0)
532    
533                                      ;**************************************************************************
534                                      ;       SUBTB
535                                      ;
536                                      ; Scale log version of difference signal by subtracting
537                                      ;   scale factor
538                                      ;
539                                      ; DLN = DL - Y
540                                      ;
541                                      ; Inputs:






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 11



542                                      ;   DL = 0iii i.fff | ffff 0000 | 0000 0000  (11SM)
543                                      ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
544                                      ;
545                                      ; Output:
546                                      ;   DLN = siii i.fff | ffff 0000 | 0000 0000 (12TC)
547                                      ;
548                                      ;**************************************************************************
549    
550       P:00B4 30104E  [2 -      262]  SUBTB_T   AND     X0,B      #QUANTAB,R0             ;Truncate Y to 11 bits (Y>>2),
551                                                                                          ; get quantization table base
552       P:00B5 45F414  [4 -      266]            SUB     B,A       #>QUANTAB+2,X1          ;Find DLN=DL-Y,
                 000012
553                                                                                          ; get offset for quan. conversion
554    
555                                      ;**************************************************************************
556                                      ;       QUAN
557                                      ;
558                                      ; Quantize difference signal in log domain
559                                      ;
560                                      ;    log2|D(k)| - Y(k) | |I(k)|
561                                      ;    ------------------+--------
562                                      ;      [3.12, + inf)   |   7
563                                      ;      [2.72, 3.12)    |   6
564                                      ;      [2.34, 2.72)    |   5
565                                      ;      [1.91, 2.34)    |   4
566                                      ;      [1.38, 1.91)    |   3
567                                      ;      [0.62, 1.38)    |   2
568                                      ;      [-0.98, 0.62)   |   1
569                                      ;      (- inf, -0.98)  |   0
570                                      ;
571                                      ; Inputs:
572                                      ;   DLN = siii i.fff | ffff 0000 | 0000 0000 (12TC)
573                                      ;   DS = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
574                                      ;
575                                      ; Output:
576                                      ;   I = siii 0000 | 0000 0000 | 0000 0000 (ADPCM format)
577                                      ;
578                                      ;**************************************************************************
579    
580       P:00B7 44D800  [2 -      268]            MOVE              X:(R0)+,X0              ;Get quan table value
581       P:00B8 44D845  [2 -      270]  TSTDLN_T  CMP     X0,A      X:(R0)+,X0              ;Compare to DLN
582       P:00B9 0E10B8  [4 -      274]            JGE     <TSTDLN_T                         ;If value<DLN try next range
583       P:00BA 220E00  [2 -      276]            MOVE              R0,A                    ;When range found...
584                                                                                          ; subtract pointer from
585       P:00BB 4CA464  [2 -      278]            SUB     X1,A                  Y:LSHFT-20,X0 ; base to get IMAG=|I|  
586                                      ;   A1 = 0000 0000 | 0000 0000 | 0000 0iii (A2=A0=0)
587       P:00BC 218500  [2 -      280]            MOVE              A1,X1
588       P:00BD 20EFA0  [2 -      282]            MPY     X0,X1,A   Y1,B                    ;Shift IMAG <<20, result is
589                                                                                          ; in A0, move DS (from LOG) into B
590       P:00BE 210E00  [2 -      284]            MOVE              A0,A
591                                      ;   A1 = 0iii 0000 | 0000 0000 | 0000 0000 (A2=A0=0)
592       P:00BF 540B00  [2 -      286]            MOVE              A1,X:IMAG               ;Save IMAG
593       P:00C0 24F003  [2 -      288]            TST     A         #<$F0,X0                ;Check IMAG, get invert mask
594       P:00C1 0EA0C4  [4 -      292]            JEQ     <INVERT_T                         ;If IMAG=0 invert bits
595       P:00C2 20000B  [2 -      294]            TST     B                                 ;If IMAG!=0, check DS
596       P:00C3 0E30C5  [4 -      298]            JPL     <IOUT_T                           ;If DS=1 don't invert IMAG






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 12



597       P:00C4 200043  [2 -      300]  INVERT_T  EOR     X0,A                              ;If DS=0 or IMAG=0,
598                                                                                          ; invert IMAG
599       P:00C5 218E00  [2 -      302]  IOUT_T    MOVE              A1,A                    ;Adjust sign extension
600    
601                                      ;**************************************************************************
602                                      ;
603                                      ; Output ADPCM data (I) here. For simulation purposes the Output 
604                                      ; Word to File subroutine on the 56001 ADS board is used.
605                                      ;
606                                      ;**************************************************************************
607    
608       P:00C6 240100  [2 -      304]            MOVE              #1,X0                   ;Output ADPCM word (I)
609       P:00C7 0BF080  [6 -      310]            JSR     $E004
                 00E004
610    
611                                      ;**************************************************************************
612                                      ;       RECONST
613                                      ;
614                                      ; Reconstruct quantized difference signal in the log domain
615                                      ;
616                                      ;     |I(k)| | log2|DQ(k)| - Y(k)
617                                      ;    --------+-------------------
618                                      ;       7    |      3.32
619                                      ;       6    |      2.91
620                                      ;       5    |      2.52
621                                      ;       4    |      2.13
622                                      ;       3    |      1.66
623                                      ;       2    |      1.05
624                                      ;       1    |      0.031
625                                      ;       0    |      - inf
626                                      ;
627                                      ; Inputs:
628                                      ;   I = iiii 0000 | 0000 0000 | 0000 0000  (ADPCM format)
629                                      ;
630                                      ; Output:
631                                      ;   DQLN = siii i.fff | ffff 0000 | 0000 0000  (12TC)
632                                      ;   DQS = sXXX 0000 | 0000 0000 | 0000 0000  (1TC)
633                                      ;
634                                      ;**************************************************************************
635    
636       P:00C9 193000  [4 -      314]            MOVE              A,Y1        A,X:I_T     ;Save DQS (sign of I) to Y1
                 000000
637       P:00CB 341800  [2 -      316]            MOVE              #IQUANTAB,R4            ;Set lookup table base
638                                      ;   X1 = 0000 0000 | 0000 0000 | 0000 0iii = |I| (from QUAN)
639       P:00CC 20BC00  [2 -      318]            MOVE              X1,N4                   ;Load |I| as offset
640       P:00CD 578200  [2 -      320]            MOVE              X:Y_T,B                 ; into IQUAN table, get Y
641       P:00CE 56EC00  [4 -      324]            MOVE              X:(R4+N4),A             ;Lookup DQLN
642    
643                                      ;**************************************************************************
644                                      ;       ADDA
645                                      ;
646                                      ; Add scale factor to log version of quantized difference
647                                      ;   signal
648                                      ;
649                                      ; DQL = DQLN + Y
650                                      ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 13



651                                      ; Inputs:
652                                      ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
653                                      ;   DQLN = siii i.fff | ffff 0000 | 0000 0000  (12TC)
654                                      ;
655                                      ; Output:
656                                      ;   DQL = siii i.fff | ffff 0000 | 0000 0000  (12TC)
657                                      ;
658                                      ;**************************************************************************
659    
660       P:00CF 4EDF00  [2 -      326]            MOVE                          Y:(R7)+,Y0  ;Get mask K8 for ADDA
661       P:00D0 4CDF5E  [2 -      328]            AND     Y0,B                  Y:(R7)+,X0  ;Truncate Y to 11 bits (Y<<2),
662                                                                                          ; get mask K9
663       P:00D1 250810  [2 -      330]            ADD     B,A       #<$08,X1                ;Find DQL=DQLN+(Y<<2), get '1'
664    
665                                      ;**************************************************************************
666                                      ;       ANTILOG
667                                      ;
668                                      ; Convert quantized difference signal from log to linear
669                                      ;   domain
670                                      ;
671                                      ; Input:
672                                      ;   DQL = siii i.fff | ffff 0000 | 0000 0000  (12TC)
673                                      ;   DQS = sXXX 0000 | 0000 0000 | 0000 0000  (1TC)
674                                      ;
675                                      ; Outputs:
676                                      ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
677                                      ;
678                                      ;**************************************************************************
679    
680       P:00D2 0E30D9  [4 -      334]            JPL     <CONVLOG_T                        ;If DQL>=0 (DS=0) convert DQL,
681                                                                                          ; else DQL<0 (DS=1), set |DQ|=0
682       P:00D3 248071  [2 -      336]            TFR     Y1,A      #<$80,X0                ;Get DQS (MSB of I), get mask
683       P:00D4 2F0046  [2 -      338]            AND     X0,A      #0,B                    ;Mask off DQS, set |DQ|=0
684                                      ;   A1 = s000 0000 | 0000 0000 | 0000 0000  (A2=sign ext, A0=0)
685       P:00D5 5D1F00  [2 -      340]            MOVE                          B1,Y:DQMAG  ;Save DQMAG=|DQ|
686       P:00D6 205F00  [2 -      342]            MOVE              (R7)+                   ;Adjust constant pointer
687       P:00D7 205F00  [2 -      344]            MOVE              (R7)+
688       P:00D8 0C00ED  [4 -      348]            JMP     <SAVEDQ_T
689    
690       P:00D9 21CF46  [2 -      350]  CONVLOG_T AND     X0,A      A,B                     ;Find fractional part (DMN),
691                                                                                          ; save DS
692                                      ;   A1 = 0000 0.fff | ffff 0000 | 0000 0000  (A2=A0=0)
693       P:00DA 247862  [2 -      352]            OR      X1,A      #<$78,X0                ;Add implied '1' to DMN to
694                                                                                          ; find DQT, get integer mask
695                                      ;   A1 = 0000 1.fff | ffff 0000 | 0000 0000  (A2=A0=0)
696       P:00DB 4EB34E  [2 -      354]            AND     X0,B                  Y:RSHFT+19,Y0 ;Find integer part (DEX),
697                                                                                          ; get shift constant
698                                      ;   B1 = 0iii i.000 | 0000 0000 | 0000 0000  (B2=B0=0)
699       P:00DC 21A400  [2 -      356]            MOVE              B1,X0
700       P:00DD 4CDFD8  [2 -      358]            MPY     X0,Y0,B               Y:(R7)+,X0  ;Shift DEX>>19, get '10' (K10)
701                                      ;   A1 = 0000 1.fff | ffff 0000 | 0000 0000  (A2=A0=0)
702                                      ;   B1 = 0000 0000 | 0000 0000 | 0000 iiii.  (B2=B0=0)
703       P:00DE 4CDF4C  [2 -      360]            SUB     X0,B                  Y:(R7)+,X0  ;Find DQT shift=DEX-'10',
704                                                                                          ; get mask K11
705       P:00DF 0EA0E9  [4 -      364]            JEQ     <TRUNCDQM_T                       ;If DEX=10, no shift
706       P:00E0 0E90E4  [4 -      368]            JLT     <SHFRDQ_T                         ;If DEX<10, shift right






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 14



707       P:00E1 06CD20  [4 -      372]            REP     B1                                ;Else shift DQT left
708       P:00E2 200033  [2 -      374]            LSL     A                                 ; up to 4 times
709       P:00E3 0C00E9  [4 -      378]            JMP     <TRUNCDQM_T
710    
711       P:00E4 20003E  [2 -      380]  SHFRDQ_T  NEG     B                                 ;Find 10-DEX
712       P:00E5 21BD00  [2 -      382]            MOVE              B1,N5                   ;Use 10-DEX for shift lookup
713       P:00E6 218600  [2 -      384]            MOVE              A1,Y0
714       P:00E7 4DED00  [4 -      388]            MOVE                          Y:(R5+N5),X1 ;Lookup shift constant
715       P:00E8 2000E0  [2 -      390]            MPY     X1,Y0,A                           ;Shift DQT right up to 9 times
716       P:00E9 2F8046  [2 -      392]  TRUNCDQM_T AND    X0,A      #<$80,B                 ;Truncate to find DQMAG=|DQ|,
717                                                                                          ; get sign mask
718                                      ;   A1 = 0iii iiii | iiii iii.0 | 0000 0000  (A2=A0=0)
719       P:00EA 5C1F7E  [2 -      394]            AND     Y1,B                  A1,Y:DQMAG  ;Mask off DQS, save DQMAG           
720                                      ;   B1 = s000 0000 | 0000 0000 | 0000 0000  (B2=?, B0=0)
721       P:00EB 21A400  [2 -      396]            MOVE              B1,X0
722       P:00EC 200042  [2 -      398]            OR      X0,A                              ;Add DQS to DQMAG to get DQ
723                                      ;   A1 = siii iiii | iiii iii.0 | 0000 0000  (A2=?, A0=0)
724       P:00ED 540100  [2 -      400]  SAVEDQ_T  MOVE              A1,X:DQ_T               ;Save DQ
725    
726                                      ;**************************************************************************
727                                      ;       TRANS
728                                      ;
729                                      ; Transition detector
730                                      ;
731                                      ; TR(k) = 1 if TD(k)=1 and |DQ(k)|> 24 x 2**(YL(k))
732                                      ;         0 otherwise
733                                      ;
734                                      ; Inputs:
735                                      ;   TD = i000 0000 | 0000 0000 | 0000 0000  (1TC)
736                                      ;   YL = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
737                                      ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
738                                      ;
739                                      ; Output:
740                                      ;   TR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
741                                      ;
742                                      ;**************************************************************************
743    
744       P:00EE 5E8900  [2 -      402]            MOVE                          Y:TD_T,A    ;Get TD
745       P:00EF 2E0003  [2 -      404]            TST     A         #0,A                    ;Check TD, set TR=0
746       P:00F0 0EA10E  [4 -      408]            JEQ     <SAVETR_T                         ;If TD=0 save TR=0
747                                                                                          ; else test DQ and YL
748       P:00F1 5E8B00  [2 -      410]            MOVE                          Y:YL_T,A    ;Get YL
749       P:00F2 4CDF09  [2 -      412]            TFR     A,B                   Y:(R7)+,X0  ;Save YL, get mask K12
750       P:00F3 240846  [2 -      414]            AND     X0,A      #<$08,X0                ;Find YLFRAC (YL>>10), get '1'
751       P:00F4 1DDF42  [2 -      416]            OR      X0,A      B,X1        Y:(R7)+,Y1  ;Add implied '1' to YLFRAC,
752                                                                                          ; get mask K13
753       P:00F5 4CDFF8  [2 -      418]            MPY     Y1,X1,B               Y:(R7)+,X0  ;Find YLINT=YL>>15, get '8' (K14)
754       P:00F6 21AF00  [2 -      420]            MOVE              B1,B                    ;Adjust sign extension
755       P:00F7 4CDF4D  [2 -      422]            CMP     X0,B                  Y:(R7)+,X0  ;Compare YLINT to '8', get '5' (K15)
756       P:00F8 0E70FF  [4 -      426]            JGT     <MAXTHR_T                         ;If YLINT>8 set maximum THR2
757       P:00F9 20004C  [2 -      428]            SUB     X0,B                              ;Find YLINT-5
758       P:00FA 0EA106  [4 -      432]            JEQ     <SETDQTHR_T                       ;If YLINT=5 don't shift
759       P:00FB 0E9101  [4 -      436]            JLT     <RSHFT_T                          ;If YLINT<5 shift right
760    
761       P:00FC 06CD20  [4 -      440]            REP     B1                                ;Else shift YLFRAC left
762       P:00FD 200033  [2 -      442]            LSL     A                                 ; up to 3 times to get THR1






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 15



763       P:00FE 0C0106  [4 -      446]            JMP     <SETDQTHR_T
764    
765       P:00FF 2E7C00  [2 -      448]  MAXTHR_T  MOVE              #<$7C,A                 ;Set maximum THR2 (31<<9)
766       P:0100 0C0106  [4 -      452]            JMP     <SETDQTHR_T
767    
768       P:0101 20003E  [2 -      454]  RSHFT_T   NEG     B                                 ;Find 5-YLINT
769       P:0102 21BD00  [2 -      456]            MOVE              B1,N5                   ;Use 5-YLINT for shift lookup
770       P:0103 218400  [2 -      458]            MOVE              A1,X0
771       P:0104 4DED00  [4 -      462]            MOVE                          Y:(R5+N5),X1 ;Lookup shift constant
772       P:0105 2000A0  [2 -      464]            MPY     X0,X1,A                           ;Shift YLFRAC right up to ? times
773                                                                                          ; to get THR1
774       P:0106 4CDF09  [2 -      466]  SETDQTHR_T TFR    A,B                   Y:(R7)+,X0  ;Get mask K16
775       P:0107 20002B  [2 -      468]            LSR     B                                 ;Find THR2>>1
776       P:0108 20004E  [2 -      470]            AND     X0,B                              ;Truncate THR2>>1
777       P:0109 250010  [2 -      472]            ADD     B,A       #0,X1                   ;Find THR2+(THR2>>1)
778       P:010A 200023  [2 -      474]            LSR     A                                 ;Find (THR2+(THR2>>1)>>1
779       P:010B 4C9F46  [2 -      476]            AND     X0,A                  Y:DQMAG,X0  ;Truncate to find DQTHR, get DQMAG
780       P:010C 2E8045  [2 -      478]            CMP     X0,A      #<$80,A                 ;Compare DQMAG to DQTHR, set TR=1
781       P:010D 027060  [2 -      480]            TGT     X1,A                              ;If DQMAG>DQTHR leave TR=1,
782                                                                                          ; else DQMAG<=DQTHR, set TR=0
783       P:010E 5C0E00  [2 -      482]  SAVETR_T  MOVE                          A1,Y:TR_T   ;Save TR
784    
785                                      ;**************************************************************************
786                                      ;       ADDB
787                                      ;
788                                      ; Add quantized difference signal and signal estimate
789                                      ;   to form reconstructed signal
790                                      ;
791                                      ; SR(k-n) = SE(k-n) + DQ(k-n)
792                                      ;
793                                      ; Inputs:
794                                      ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
795                                      ;   SE = siii iiii | iiii iii.0 | 0000 0000  (15TC)
796                                      ;
797                                      ; Output:
798                                      ;   SR = siii iiii | iiii iiii. | 0000 0000  (16TC)
799                                      ;
800                                      ;**************************************************************************
801    
802       P:010F 5F8000  [2 -      484]            MOVE                          Y:SE_T,B    ;Get SE
803       P:0110 56812A  [2 -      486]            ASR     B         X:DQ_T,A                ;Sign extend SE to get SEI, get DQS
804       P:0111 5E9F03  [2 -      488]            TST     A                     Y:DQMAG,A   ;Check DQS, get DQMAG
805       P:0112 0E3114  [4 -      492]            JPL     <SHFTDQ_T                         ;If DQS=0 continue
806       P:0113 200036  [2 -      494]            NEG     A                                 ;Convert DQ to 2's comp
807       P:0114 200022  [2 -      496]  SHFTDQ_T  ASR     A                                 ;Sign extend DQ to get DQI
808       P:0115 374818  [2 -      498]            ADD     A,B       #CONST17,R7             ;Find SR=DQ+SE, update const pointer
809    
810                                      ;**************************************************************************
811                                      ;       ADDC
812                                      ;
813                                      ; Obtain sign of addition of the quantized difference
814                                      ;   signal and the partial signal estimate
815                                      ;
816                                      ; P(k) = DQ(k) + SEZ(k)
817                                      ; PK0 = sign of P(k)
818                                      ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 16



819                                      ; Inputs:
820                                      ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
821                                      ;   SEZ = siii iiii | iiii iii.0 | 0000 0000 (15TC)
822                                      ;
823                                      ; Output:
824                                      ;   PK0 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
825                                      ;   SIGPK = i000 0000 | 0000 0000 | 0000 0000  (1TC)
826                                      ;
827                                      ;**************************************************************************
828    
829       P:0116 5D0200  [2 -      500]            MOVE                          B1,Y:SR_T   ;Save SR
830       P:0117 5F8100  [2 -      502]            MOVE                          Y:SEZ_T,B   ;Get SEZ
831       P:0118 20002A  [2 -      504]            ASR     B                                 ;Sign extend SEZ to SEZI
832       P:0119 2F0010  [2 -      506]            ADD     B,A       #0,B                    ;Find DQSEZ=DQ+SEZ,
833                                                                                          ; set SIGPK=0
834       P:011A 248003  [2 -      508]            TST     A         #<$80,X0                ;Check DQSEZ, get '1'
835       P:011B 02A048  [2 -      510]            TEQ     X0,B                              ;If DQSEZ=0, SIGPK=1,
836                                                                                          ; else SIGPK=0
837    
838       P:011C 4C8400  [2 -      512]            MOVE                          Y:PK1_T,X0
839       P:011D 4C0500  [2 -      514]            MOVE                          X0,Y:PK2_T  ;Delay previous PK1
840       P:011E 4C8300  [2 -      516]            MOVE                          Y:PK0_T,X0
841       P:011F 4C0400  [2 -      518]            MOVE                          X0,Y:PK1_T  ;Delay previous PK0
842       P:0120 5C0300  [2 -      520]            MOVE                          A1,Y:PK0_T  ;Save new PK0
843       P:0121 5D0C00  [2 -      522]            MOVE                          B1,Y:SIGPK_T ;Save SIGPK
844       P:0122 4C8543  [2 -      524]            EOR     X0,A                  Y:PK2_T,X0  ;Find PKS1=PK0**PK1
845                                                                                          ; for UPA1 & UPA2
846       P:0123 540C00  [2 -      526]            MOVE              A1,X:PKS1               ;Save PKS1
847       P:0124 5E8300  [2 -      528]            MOVE                          Y:PK0_T,A
848       P:0125 3A0343  [2 -      530]            EOR     X0,A      #3,N2                   ;Find PKS2=PK0**PK2 for UPA2
849       P:0126 540D00  [2 -      532]            MOVE              A1,X:PKS2               ;Save PKS2
850       P:0127 205A00  [2 -      534]            MOVE              (R2)+                   ;Adjust data buffer pointer so
851       P:0128 205A00  [2 -      536]            MOVE              (R2)+                   ; that R2 points to DQ1S
852    
853                                      ;**************************************************************************
854                                      ;       XOR
855                                      ;
856                                      ; Find one bit "exclusive or" of the sign of difference
857                                      ;   signal and the sign of delayed difference signal.
858                                      ;
859                                      ; Un = sgn[DQ(k)] XOR sgn[DQ(k-n)]
860                                      ;
861                                      ; Inputs:
862                                      ;   DQ = siii iiii | iiii iii.0 | 0000 0000 (15SM)
863                                      ;   DQnS = X:(R2+n) sXXX XXXX | XXXX XXXX | 0000 0000
864                                      ;
865                                      ; Outputs:
866                                      ;   Un = sXXX XXXX | XXXX XXXX | 0000 0000 (1TC)
867                                      ;
868                                      ;**************************************************************************
869                                      ;**************************************************************************
870                                      ;       UPB
871                                      ;
872                                      ; Update the coefficients of the sixth order predictor
873                                      ;
874                                      ; Bn(k) = [1-(2**-8)] * Bn(k-1)






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 17



875                                      ;           + (2**-7) * sgn[DQ(k)] * sgn[DQ(k-n)]
876                                      ;
877                                      ; Inputs:
878                                      ;   Bn = Y:(R6+n) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
879                                      ;   DQ = siii iiii | iiii iii.0 | 0000 0000 (15SM)
880                                      ;   Un = sXXX XXXX | XXXX XXXX | 0000 0000 (1TC)
881                                      ;
882                                      ; Outputs:
883                                      ;   BnP = Y:(R6+n) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
884                                      ;
885                                      ;**************************************************************************
886    
887       P:0129 5E9F00  [2 -      538]            MOVE                          Y:DQMAG,A   ;Get DQMAG
888       P:012A 468103  [2 -      540]            TST     A         X:DQ_T,Y0               ;Check DQMAG, get DQS
889       P:012B 0E2139  [4 -      544]            JNE     <XORUPB_T                         ;If DQMAG!=0 use section with XOR,
890                                                                                          ; else use section with no XOR
891                                                                                          ; (because UGBn=0 if DQMAG=0)
892    
893                                      ; UPB without XOR
894       P:012C 4DA800  [2 -      546]            MOVE                          Y:RSHFT+8,X1 ;Get shift constant
895       P:012D 205F00  [2 -      548]            MOVE              (R7)+                   ;Adjust constant pointer
896       P:012E 205F00  [2 -      550]            MOVE              (R7)+
897       P:012F 4CDF00  [2 -      552]            MOVE                          Y:(R7)+,X0  ;Get mask K19
898       P:0130 060680  [6 -      558]            DO      #6,ENDLOOP_T                      ;Do UPB for B1-B6
                 000137
899       P:0132 C9CA00  [2 -      560]            MOVE              X:(R2)+N2,A Y:(R6),Y1   ;Get Bn (& DQnS but don't use)
900       P:0133 2000F0  [2 -      562]            MPY     X1,Y1,A                           ;Find Bn>>8
901       P:0134 200046  [2 -      564]            AND     X0,A                              ;Truncate (Bn>>8)
902       P:0135 200036  [2 -      566]            NEG     A                                 ;Find UBn=ULBn=-(Bn>>8)
903       P:0136 200070  [2 -      568]            ADD     Y1,A                              ;Find BnP=Bn+UBn
904       P:0137 5C5E00  [2 -      570]            MOVE                          A1,Y:(R6)+  ;Store BnP to Bn
905       P:0138 0C0149  [4 -      574]  ENDLOOP_T JMP     <UPA2_T
906    
907                                      ; UPB with XOR
908       P:0139 4CDF00  [2 -      576]  XORUPB_T  MOVE                          Y:(R7)+,X0  ;Get +gain (K17)
909       P:013A 060680  [6 -      582]            DO      #6,UPTR_T                         ;Do UPB and XOR for B1-B6
                 000146
910       P:013C C9CA00  [2 -      584]            MOVE              X:(R2)+N2,A Y:(R6),Y1   ;Get Bn & DQnS
911       P:013D 4DDF53  [2 -      586]            EOR     Y0,A                  Y:(R7)+,X1  ;Find Un=DQS**DQnS (XOR),
912                                                                                          ; get -gain (K18)
913       P:013E 023040  [2 -      588]            TPL     X0,A                              ;If Un=0 set UGBn=+gain
914       P:013F 02B060  [2 -      590]            TMI     X1,A                              ;If Un=1 set UGBn=-gain
915       P:0140 4DA800  [2 -      592]            MOVE                          Y:RSHFT+8,X1 ;Get shift constant
916       P:0141 4DD7F8  [2 -      594]            MPY     X1,Y1,B               Y:(R7)-,X1  ;Shift Bn>>8, get mask K19
917       P:0142 20006E  [2 -      596]            AND     X1,B                              ;Truncate (Bn>>8)
918       P:0143 20003E  [2 -      598]            NEG     B                                 ;Find ULBn=-(Bn>>8)
919       P:0144 200010  [2 -      600]            ADD     B,A                               ;Find UBn=UGBn+ULBn
920       P:0145 200070  [2 -      602]            ADD     Y1,A                              ;Find BnP=Bn+UBn
921       P:0146 5C5E00  [2 -      604]            MOVE                          A1,Y:(R6)+  ;Store BnP to Bn
922       P:0147 205F00  [2 -      606]  UPTR_T    MOVE              (R7)+                   ;Adjust constant pointer
923       P:0148 205F00  [2 -      608]            MOVE              (R7)+
924    
925                                      ;**************************************************************************
926                                      ;       UPA2
927                                      ;
928                                      ; Update the A2 coefficient of the second order predictor.






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 18



929                                      ;
930                                      ; A2(k) = [1-(2**-7)] * A2(k-1)
931                                      ;           + (2**-7) * { sgn[P(k)] * sgn[P(k-2)]
932                                      ;               - F[A1(k-1)] * sgn[P(k)] * sgn[P(k-1)] }
933                                      ;
934                                      ; F[A1(k)] = 4 * A1       if |A1|<=(2**-1)
935                                      ;          = 2 * sgn(A1)  if |A1|>(2**-1)
936                                      ;
937                                      ; Inputs:
938                                      ;   A1 = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
939                                      ;   A2 = Y:(R6+1) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
940                                      ;   SIGPK = i000 0000 | 0000 0000 | 0000 0000  (1TC)
941                                      ;   PK0 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
942                                      ;   PK1 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
943                                      ;   PK2 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
944                                      ;     (Note: PKS1 & PKS2 have been previously calculated)
945                                      ;
946                                      ; Outputs:
947                                      ;   A2T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
948                                      ;
949                                      ;**************************************************************************
950    
951       P:0149 568D00  [2 -      610]  UPA2_T    MOVE              X:PKS2,A                ;Get PKS2=PK0**PK2
952       P:014A 261003  [2 -      612]            TST     A         #<$10,Y0                ;Check PKS2, get '+1'
953       P:014B 27F000  [2 -      614]            MOVE              #<$F0,Y1                ;Get '-1'
954       P:014C 023050  [2 -      616]            TPL     Y0,A                              ;If PKS2=0, set UGA2A='+1'
955       P:014D 02B070  [2 -      618]            TMI     Y1,A                              ;If PKS2=1, set UGA2A='-1'
956       P:014E 16DE00  [2 -      620]            MOVE              A,X1        Y:(R6)+,A   ;Save UGA2A, get A1
957       P:014F 4EDF00  [2 -      622]            MOVE                          Y:(R7)+,Y0  ;Get '+1.99' (K20)
958       P:0150 4FDF55  [2 -      624]            CMP     Y0,A                  Y:(R7)+,Y1  ;Check A1, get '-1.99' (K21)
959       P:0151 027050  [2 -      626]            TGT     Y0,A                              ;If A1>=1/2, set FA1='1.99'
960       P:0152 578C75  [2 -      628]            CMP     Y1,A      X:PKS1,B                ;Check A1 again, get PKS1=PK0**PK1
961       P:0153 029070  [2 -      630]            TLT     Y1,A                              ;If A1<=-1/2, set FA1='-1.99'
962       P:0154 24000B  [2 -      632]            TST     B         #0,X0                   ;Check PKS1
963       P:0155 0EB157  [4 -      636]            JMI     <FINDSUM_T                        ;If PKS1=1, FA=FA1
964       P:0156 200036  [2 -      638]            NEG     A                                 ; else PKS1=0, set FA=-FA1
965       P:0157 4FA560  [2 -      640]  FINDSUM_T ADD     X1,A                  Y:RSHFT+5,Y1 ;Find UGA2B=UGA2A+FA,
966                                                                                          ; get shift constant
967       P:0158 21C500  [2 -      642]            MOVE              A,X1
968       P:0159 4DDFF0  [2 -      644]            MPY     X1,Y1,A               Y:(R7)+,X1  ;Find UGA2B>>7, get mask K22
969       P:015A 5F8C66  [2 -      646]            AND     X1,A                  Y:SIGPK_T,B ;Truncate UGA2, get SIGPK
970       P:015B 4EE60B  [2 -      648]            TST     B                     Y:(R6),Y0   ;Check SIGPK, get A2
971       P:015C 02B040  [2 -      650]            TMI     X0,A                              ;If SIGPK=1, set UGA2=0
972       P:015D 4CA700  [2 -      652]            MOVE                          Y:RSHFT+7,X0 ;Get shift constant
973       P:015E 2000D8  [2 -      654]            MPY     Y0,X0,B                           ;Find A2>>7
974       P:015F 20006E  [2 -      656]            AND     X1,B                              ;Truncate to find A2>>7
975       P:0160 24D03E  [2 -      658]            NEG     B         #<$D0,X0                ;Find ULA2=-(A2>>7), get A2LL
976       P:0161 253010  [2 -      660]            ADD     B,A       #<$30,X1                ;Find UA2=UGA2+ULA2, get A2UL
977       P:0162 4FDF50  [2 -      662]            ADD     Y0,A                  Y:(R7)+,Y1  ;Find A2T=A2+UA2, get -gain (K23)
978    
979                                      ;**************************************************************************
980                                      ;       LIMC
981                                      ;
982                                      ; Limit the A2 coefficient of the second order predictor.
983                                      ;
984                                      ;   |A2(k)| <= '0.75' 






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 19



985                                      ;
986                                      ; Inputs:
987                                      ;   A2T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
988                                      ;
989                                      ; Outputs:
990                                      ;   A2P = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
991                                      ;
992                                      ;**************************************************************************
993    
994       P:0163 4EDF45  [2 -      664]            CMP     X0,A                  Y:(R7)+,Y0  ;Check A2P, get +gain (K24)
995       P:0164 029040  [2 -      666]            TLT     X0,A                              ;If A2P<-0.75, set A2P=-0.75
996       P:0165 578C65  [2 -      668]            CMP     X1,A      X:PKS1,B                ;Check A2P again, get PKS1=PK0**PK1
997       P:0166 027060  [2 -      670]            TGT     X1,A                              ;If A2P>0.75, set A2P=0.75
998       P:0167 5E0D00  [2 -      672]            MOVE                          A,Y:A2P_T   ;Save A2P
999       P:0168 5E5600  [2 -      674]            MOVE                          A,Y:(R6)-   ;Save A2P to A2
1000   
1001                                     ;**************************************************************************
1002                                     ;       UPA1
1003                                     ;
1004                                     ; Update the A1 coefficient of the second order predictor.
1005                                     ;
1006                                     ; A1(k) = [1-(2**-8)] * A1(k-1)
1007                                     ;           + 3 * (2**-8) * sgn[P(k)] * sgn[P(k-1)]
1008                                     ;
1009                                     ; Inputs:
1010                                     ;   A1 = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1011                                     ;   SIGPK = Y:(R0) = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1012                                     ;   PK0 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
1013                                     ;   PK1 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
1014                                     ;     (Note: PKS1 has been previously calculated)
1015                                     ;
1016                                     ; Outputs:
1017                                     ;   A1T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1018                                     ;
1019                                     ;**************************************************************************
1020   
1021      P:0169 5F8C0B  [2 -      676]            TST     B                     Y:SIGPK_T,B ;Check PKS1, get SIGPK
1022      P:016A 023050  [2 -      678]            TPL     Y0,A                              ;If PKS=0, set UGA1=+gain
1023      P:016B 02B070  [2 -      680]            TMI     Y1,A                              ;If PKS=1, set UGA1=-gain
1024      P:016C 24000B  [2 -      682]            TST     B         #0,X0                   ;Check SIGPK
1025      P:016D 02B040  [2 -      684]            TMI     X0,A                              ;If SIGPK=1, set UGA1=0
1026      P:016E 4DE600  [2 -      686]            MOVE                          Y:(R6),X1   ;Get A1
1027      P:016F 4EA800  [2 -      688]            MOVE                          Y:RSHFT+8,Y0 ;Get shift constant
1028      P:0170 4CDFE8  [2 -      690]            MPY     Y0,X1,B               Y:(R7)+,X0  ;Find A1>>8, get mask K25
1029      P:0171 20004E  [2 -      692]            AND     X0,B                              ;Truncate (A1>>8)
1030      P:0172 20003E  [2 -      694]            NEG     B                                 ;Find ULA1=-(A1>>8)
1031      P:0173 2F3C10  [2 -      696]            ADD     B,A       #<$3C,B                 ;Find UA1=UGA1+ULA1,
1032                                                                                         ; get OME='1-(2**-4)'
1033      P:0174 4C8D60  [2 -      698]            ADD     X1,A                  Y:A2P_T,X0  ;Find A1T=A1+UA1, get A2P
1034   
1035                                     ;**************************************************************************
1036                                     ;       LIMD
1037                                     ;
1038                                     ; Limit the A1 coefficient of the second order predictor.
1039                                     ;
1040                                     ;   |A1(k)| <= [1-(2**-4)] - A2(k)






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 20



1041                                     ;
1042                                     ; Inputs:
1043                                     ;   A1T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1044                                     ;   A2P = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1045                                     ;
1046                                     ; Outputs:
1047                                     ;   A1P = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1048                                     ;
1049                                     ;**************************************************************************
1050   
1051      P:0175 20004C  [2 -      700]            SUB     X0,B                              ;Find A1UL=OME-A2P
1052      P:0176 21E405  [2 -      702]            CMP     B,A       B,X0                    ;Check A1T
1053      P:0177 027040  [2 -      704]            TGT     X0,A                              ;If A1T>A1UL, set A1P=A1UL
1054      P:0178 205A3E  [2 -      706]            NEG     B         (R2)+                   ;Find A1LL=-A1UL=A2P-OME
1055      P:0179 21E405  [2 -      708]            CMP     B,A       B,X0                    ;Check A1T again
1056      P:017A 029040  [2 -      710]            TLT     X0,A                              ;If A1T<A1LL, set A1P=A1LL
1057      P:017B 5C5E00  [2 -      712]            MOVE                          A1,Y:(R6)+  ;Store A1P to A1
1058      P:017C 205E00  [2 -      714]            MOVE              (R6)+                   ;Adjust coef pointer
1059   
1060                                     ;**************************************************************************
1061                                     ;       FLOATA
1062                                     ;
1063                                     ; Converts the quantized difference signal from 15-bit
1064                                     ;   signed magnitude to floating pt. format (11FL - sign,
1065                                     ;   exp, and mant stored separately)
1066                                     ;
1067                                     ; Inputs:
1068                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000 (15SM)
1069                                     ;
1070                                     ; Outputs:
1071                                     ;   DQ0 = (11FL)
1072                                     ;    DQ0EXP = X:(R2) = 0000 0000 | 0000 0000 | 0000 eeee
1073                                     ;    DQ0MANT = X:(R2+1) = 01mm mmm0 | 0000 0000 | 0000 0000
1074                                     ;    DQ0S = X:(R2+2) = sXXX XXXX | XXXX XXXX | 0000 0000
1075                                     ;
1076                                     ;**************************************************************************
1077   
1078      P:017D 468100  [2 -      716]            MOVE              X:DQ_T,Y0               ;Get DQS
1079      P:017E 5E9F00  [2 -      718]            MOVE                          Y:DQMAG,A   ;Get MAG=DQMAG
1080      P:017F 300E03  [2 -      720]            TST     A         #$000E,R0               ;Check MAG, get exponent bias (14)
1081      P:0180 0E2184  [4 -      724]            JNE     <NORMDQ_T                         ;Test MAG
1082      P:0181 2E4000  [2 -      726]            MOVE              #<$40,A                 ;If MAG=0 set MANT=100000,
1083      P:0182 300000  [2 -      728]            MOVE              #0,R0                   ; and EXP=0
1084      P:0183 0C0191  [4 -      732]            JMP     <TRUNCDQ_T
1085      P:0184 01D815  [2 -      734]  NORMDQ_T  NORM    R0,A                              ;If MAG!=0 do NORM iteration 13
1086      P:0185 01D815  [2 -      736]            NORM    R0,A                              ; times to find MSB of MAG
1087      P:0186 01D815  [2 -      738]            NORM    R0,A
1088      P:0187 01D815  [2 -      740]            NORM    R0,A
1089      P:0188 01D815  [2 -      742]            NORM    R0,A
1090      P:0189 01D815  [2 -      744]            NORM    R0,A
1091      P:018A 01D815  [2 -      746]            NORM    R0,A
1092      P:018B 01D815  [2 -      748]            NORM    R0,A
1093      P:018C 01D815  [2 -      750]            NORM    R0,A
1094      P:018D 01D815  [2 -      752]            NORM    R0,A
1095      P:018E 01D815  [2 -      754]            NORM    R0,A
1096      P:018F 01D815  [2 -      756]            NORM    R0,A






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 21



1097      P:0190 01D815  [2 -      758]            NORM    R0,A
1098                                     ;   A1 = 01?? ???? | ???? ???0 | 0000 0000 = normalized MAG (A2=A0=0)
1099                                     ;   R0 = 0000 0000 | 0000 eeee = exponent of normalized MAG
1100   
1101      P:0191 247E00  [2 -      760]  TRUNCDQ_T MOVE              #<$7E,X0                ;Get mask
1102      P:0192 605A46  [2 -      762]            AND     X0,A      R0,X:(R2)+              ;Truncate MANT to 6 bits,
1103                                                                                         ; save EXP to DQ1EXP
1104                                     ;   A1 = 01mm mmm0 | 0000 0000 | 0000 0000  (A2=A0=0)
1105      P:0193 545A00  [2 -      764]            MOVE              A1,X:(R2)+              ;Save MANT to DQ1MANT
1106      P:0194 465A00  [2 -      766]            MOVE              Y0,X:(R2)+              ;Save DQ to DQ1S
1107   
1108                                     ;**************************************************************************
1109                                     ;       FLOATB
1110                                     ;
1111                                     ; Converts the reconstructed signal from 16-bit two's 
1112                                     ;   complement to floating pt. format (11FL - sign,
1113                                     ;   exp, and mant stored separately)
1114                                     ;
1115                                     ; Inputs:
1116                                     ;   SR = siii iiii | iiii iiii. | 0000 0000  (16TC)
1117                                     ;
1118                                     ; Outputs:
1119                                     ;   SR0 = (11FL)
1120                                     ;    SR0EXP = X:(R2) = 0000 0000 | 0000 0000 | 0000 eeee
1121                                     ;    SR0MANT = X:(R2+1) = 01mm mmm0 | 0000 0000 | 0000 0000
1122                                     ;    SR0S = X:(R2+2) = sXXX XXXX | XXXX XXXX | 0000 0000
1123                                     ;
1124                                     ;**************************************************************************
1125   
1126      P:0195 3A0F00  [2 -      768]            MOVE              #15,N2
1127      P:0196 5F8200  [2 -      770]            MOVE                          Y:SR_T,B    ;Get SR
1128      P:0197 204A00  [2 -      772]            MOVE              (R2)+N2                 ;Adjust data pointer
1129      P:0198 21E62E  [2 -      774]            ABS     B         B,Y0                    ;Find MAG=|SR|, save SRS
1130      P:0199 300F0B  [2 -      776]            TST     B         #$000F,R0               ;Load exponent bias
1131      P:019A 0E219E  [4 -      780]            JNE     <NORMSR_T                         ;Test MAG
1132      P:019B 2F4000  [2 -      782]            MOVE              #<$40,B                 ;If MAG=0 set MANT=100000,
1133      P:019C 300000  [2 -      784]            MOVE              #0,R0                   ; and EXP=0
1134      P:019D 0C01AC  [4 -      788]            JMP     <TRUNCSR_T
1135      P:019E 01D81D  [2 -      790]  NORMSR_T  NORM    R0,B                              ;If MAG!=0 do NORM iteration 14
1136      P:019F 01D81D  [2 -      792]            NORM    R0,B                              ; times to find MSB of MAG
1137      P:01A0 01D81D  [2 -      794]            NORM    R0,B
1138      P:01A1 01D81D  [2 -      796]            NORM    R0,B
1139      P:01A2 01D81D  [2 -      798]            NORM    R0,B
1140      P:01A3 01D81D  [2 -      800]            NORM    R0,B
1141      P:01A4 01D81D  [2 -      802]            NORM    R0,B
1142      P:01A5 01D81D  [2 -      804]            NORM    R0,B
1143      P:01A6 01D81D  [2 -      806]            NORM    R0,B
1144      P:01A7 01D81D  [2 -      808]            NORM    R0,B
1145      P:01A8 01D81D  [2 -      810]            NORM    R0,B
1146      P:01A9 01D81D  [2 -      812]            NORM    R0,B
1147      P:01AA 01D81D  [2 -      814]            NORM    R0,B
1148      P:01AB 01D81D  [2 -      816]            NORM    R0,B
1149                                     ;   A1 = 01?? ???? | ???? ???0 | 0000 0000  (A2=A0=0)
1150                                     ;   R0 = 0000 0000 | 0000 eeee = exponent of normalized MAG
1151   
1152      P:01AC 605A4E  [2 -      818]  TRUNCSR_T AND     X0,B      R0,X:(R2)+              ;Truncate MANT to 6 bits,






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 22



1153                                                                                         ; save EXP to SR1EXP
1154                                     ;   A1 = 01mm mmm0 | 0000 0000 | 0000 0000  (A2=A0=0)
1155      P:01AD 555A00  [2 -      820]            MOVE              B1,X:(R2)+              ;Save MANT to SR1MANT
1156      P:01AE 465A00  [2 -      822]            MOVE              Y0,X:(R2)+              ;Save SR to SR1S
1157      P:01AF 3A0300  [2 -      824]            MOVE              #3,N2
1158      P:01B0 5F8D00  [2 -      826]            MOVE                          Y:A2P_T,B   ;Get A2P
1159      P:01B1 204A00  [2 -      828]            MOVE              (R2)+N2                 ;Adjust data pointer
1160   
1161                                     ;**************************************************************************
1162                                     ;       TONE
1163                                     ;
1164                                     ; Partial band signal detection
1165                                     ;
1166                                     ; TD(k) = 1 if A2(k) < -0.71875
1167                                     ;         0 otherwise
1168                                     ;
1169                                     ; Inputs:
1170                                     ;   A2P = si.ff ffff | ffff ffff | 0000 0000  (16TC)
1171                                     ;
1172                                     ; Output:
1173                                     ;   TDP = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1174                                     ;
1175                                     ;**************************************************************************
1176   
1177      P:01B2 24D213  [2 -      830]            CLR     A         #<$D2,X0                ;Get '-.71875', set TDP=0
1178      P:01B3 25804D  [2 -      832]            CMP     X0,B      #<$80,X1                ;Check A2P, get '1'
1179      P:01B4 029060  [2 -      834]            TLT     X1,A                              ;If A2P<-.71875 set TDP=1, else TDP=0
1180      P:01B5 5C0800  [2 -      836]            MOVE                          A1,Y:TDP_T  ;Save TDP
1181      P:01B6 5C0900  [2 -      838]            MOVE                          A1,Y:TD_T   ;Save TDP to TD
1182   
1183                                     ;**************************************************************************
1184                                     ;       TRIGB
1185                                     ;
1186                                     ; Predictor trigger block
1187                                     ;
1188                                     ; If TR(k) = 1, An(k)=Bn(k)=TD(k)=0
1189                                     ;
1190                                     ; Inputs:
1191                                     ;   TR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1192                                     ;   BnP = si.ff ffff | ffff ffff | 0000 0000  (16TC)
1193                                     ;   AnP = si.ff ffff | ffff ffff | 0000 0000  (16TC)
1194                                     ;   TDP = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1195                                     ;
1196                                     ; Output:
1197                                     ;   BnR = si.ff ffff | ffff ffff | 0000 0000  (16TC)
1198                                     ;   AnR = si.ff ffff | ffff ffff | 0000 0000  (16TC)
1199                                     ;   TDR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1200                                     ;
1201                                     ;**************************************************************************
1202   
1203      P:01B7 5F8E00  [2 -      840]            MOVE                          Y:TR_T,B    ;Get TR
1204      P:01B8 2E000B  [2 -      842]            TST     B         #0,A                    ;Test TR
1205      P:01B9 0EA1C3  [4 -      846]            JEQ     <FUNCTF_T                         ;If TR=0 continue
1206      P:01BA 5E0900  [2 -      848]            MOVE                          A,Y:TD_T    ;If TR=1, set TDR=0,
1207      P:01BB 5E5E00  [2 -      850]            MOVE                          A,Y:(R6)+   ; and B1-B6,A1,A2=0
1208      P:01BC 5E5E00  [2 -      852]            MOVE                          A,Y:(R6)+






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 23



1209      P:01BD 5E5E00  [2 -      854]            MOVE                          A,Y:(R6)+
1210      P:01BE 5E5E00  [2 -      856]            MOVE                          A,Y:(R6)+
1211      P:01BF 5E5E00  [2 -      858]            MOVE                          A,Y:(R6)+
1212      P:01C0 5E5E00  [2 -      860]            MOVE                          A,Y:(R6)+
1213      P:01C1 5E5E00  [2 -      862]            MOVE                          A,Y:(R6)+
1214      P:01C2 5E5E00  [2 -      864]            MOVE                          A,Y:(R6)+
1215   
1216                                     ;**************************************************************************
1217                                     ;       FUNCTF
1218                                     ;
1219                                     ; Maps quantizer output I into F(I) function
1220                                     ;
1221                                     ;  |I(k)|  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
1222                                     ; ---------+---+---+---+---+---+---+---+---+
1223                                     ;  F[I(k)] | 7 | 3 | 1 | 1 | 1 | 0 | 0 | 0 |
1224                                     ;
1225                                     ; Inputs:
1226                                     ;   I = siii 0000 | 0000 0000 | 0000 0000
1227                                     ;
1228                                     ; Output:
1229                                     ;   FI = 0iii. 0000 | 0000 0000 | 0000 0000  (3SM)
1230                                     ;   IMAG
1231                                     ;
1232                                     ;**************************************************************************
1233   
1234      P:01C3 242000  [2 -      866]  FUNCTF_T  MOVE              #<$20,X0
1235      P:01C4 568B00  [2 -      868]            MOVE              X:IMAG,A                ;Get |I|
1236      P:01C5 245045  [2 -      870]            CMP     X0,A      #<$50,X0                ;Test for |I|<=2
1237      P:01C6 0EF1D1  [4 -      874]            JLE     <RANGE0_T
1238      P:01C7 246045  [2 -      876]            CMP     X0,A      #<$60,X0                ;Test for 3<=|I|<=5
1239      P:01C8 0EF1CF  [4 -      880]            JLE     <RANGE1_T
1240      P:01C9 200045  [2 -      882]            CMP     X0,A                              ;Test for |I|=6
1241      P:01CA 0EA1CD  [4 -      886]            JEQ     <RANGE3_T
1242      P:01CB 2E7000  [2 -      888]            MOVE              #<$70,A                 ;|I|=7, set F[I]=7
1243      P:01CC 0C01D2  [4 -      892]            JMP     <FILTA_T
1244      P:01CD 2E3000  [2 -      894]  RANGE3_T  MOVE              #<$30,A                 ;|I|=6, set F[I]=3
1245      P:01CE 0C01D2  [4 -      898]            JMP     <FILTA_T
1246      P:01CF 2E1000  [2 -      900]  RANGE1_T  MOVE              #<$10,A                 ;|I|=3,4,or 5, set F[I]=1
1247      P:01D0 0C01D2  [4 -      904]            JMP     <FILTA_T
1248      P:01D1 200013  [2 -      906]  RANGE0_T  CLR     A                                 ;|I|=0,1,or 2, set F[I]=0
1249   
1250                                     ;**************************************************************************
1251                                     ;       FILTA
1252                                     ;
1253                                     ; Update short term average of F(I)
1254                                     ;
1255                                     ; DMS(k) = (1 - 2**(-5)) * DMS(k-1) + 2**(-5) * F[I(k)]
1256                                     ;
1257                                     ; Inputs:
1258                                     ;   FI = 0iii. 0000 | 0000 0000 | 0000 0000  (3SM)
1259                                     ;   DMS = 0iii. ffff | ffff f000 | 0000 0000  (12SM)
1260                                     ;
1261                                     ; Output:
1262                                     ;   DMSP = 0iii. ffff | ffff f000 | 0000 0000  (12SM)
1263                                     ;
1264                                     ;**************************************************************************






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 24



1265   
1266      P:01D2 4E8600  [2 -      908]  FILTA_T   MOVE                          Y:DMS_T,Y0  ;Get DMS
1267      P:01D3 21CF54  [2 -      910]            SUB     Y0,A      A,B                     ;Find DIF=FI-DMS, save FI
1268      P:01D4 11DF00  [2 -      912]            MOVE              A,X0        Y:(R7)+,Y1  ;Save DIF, get mask K26
1269      P:01D5 4CDFC0  [2 -      914]            MPY     X0,Y1,A               Y:(R7)+,X0  ;Find DIFSX=DIF>>5, get mask K27
1270      P:01D6 4F8746  [2 -      916]            AND     X0,A                  Y:DML_T,Y1  ;Truncate DIFSX, get DML
1271      P:01D7 4DA750  [2 -      918]            ADD     Y0,A                  Y:RSHFT+7,X1 ;Find DMSP=DIFSX+DMS
1272   
1273                                     ;**************************************************************************
1274                                     ;       FILTB
1275                                     ;
1276                                     ; Update long term average of F(I)
1277                                     ;
1278                                     ; DML(k) = (1 - 2**(-7)) * DML(k-1) + 2**(-7) * F[I(k)]
1279                                     ;
1280                                     ; Inputs:
1281                                     ;   FI = 0iii. 0000 | 0000 0000 | 0000 0000  (3SM)
1282                                     ;   DML = 0iii. ffff | ffff fff0 | 0000 0000  (14SM)
1283                                     ;
1284                                     ; Output:
1285                                     ;   DMLP = 0iii. ffff | ffff fff0 | 0000 0000  (14SM)
1286                                     ;
1287                                     ;**************************************************************************
1288   
1289      P:01D8 5C067C  [2 -      920]            SUB     Y1,B                  A1,Y:DMS_T  ;Find DIF=FI-DML
1290      P:01D9 21A400  [2 -      922]            MOVE              B1,X0
1291      P:01DA 4CDFA8  [2 -      924]            MPY     X0,X1,B               Y:(R7)+,X0  ;Find DFISX=DIF>>7, get mask K28
1292      P:01DB 20004E  [2 -      926]            AND     X0,B                              ;Truncate DIFSX
1293      P:01DC 4DA378  [2 -      928]            ADD     Y1,B                  Y:RSHFT+3,X1 ;Find DMLP=DIFSX+DML
1294   
1295                                     ;**************************************************************************
1296                                     ;       SUBTC
1297                                     ;
1298                                     ; Compute magnitude of the difference of short and long
1299                                     ;  term functions of quantizer output sequence and then
1300                                     ;  perform threshold comparison for quantizing speed control
1301                                     ;  parameter.
1302                                     ;
1303                                     ; AX = 1  if Y(k)>=3, TD(k)=1, & |DMS(k)-DML(k)|>(2**-3)*DML(k)
1304                                     ;    = 0  otherwise
1305                                     ;
1306                                     ; Input:
1307                                     ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1308                                     ;   DMSP = 0iii. ffff | ffff f000 | 0000 0000  (12SM)
1309                                     ;   DMLP = 0iii. ffff | ffff fff0 | 0000 0000  (14SM)
1310                                     ;   TDP = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1311                                     ;
1312                                     ; Output:
1313                                     ;   AX = 0i0.0 0000 | 0000 0000 | 0000 0000  (1SM)
1314                                     ;
1315                                     ;**************************************************************************
1316   
1317      P:01DD 5D0714  [2 -      930]            SUB     B,A                   B1,Y:DML_T  ;Find DIF=DMSP-DMLP, save DML
1318      P:01DE 21A626  [2 -      932]            ABS     A         B1,Y0                   ;Find DIFM=|DIF|
1319      P:01DF 2618E8  [2 -      934]            MPY     X1,Y0,B   #<$18,Y0                ;Find DTHR=DMLP>>3, get '3'
1320      P:01E0 24404E  [2 -      936]            AND     X0,B      #<$40,X0                ;Truncate DTHR, get '1'






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 25



1321      P:01E1 2F0005  [2 -      938]            CMP     B,A       #0,B                    ;Compare DIFM & DTHR, set AX=0
1322      P:01E2 021048  [2 -      940]            TGE     X0,B                              ;If DIFM>=DTHR set AX=1
1323      P:01E3 5E8800  [2 -      942]            MOVE                          Y:TDP_T,A   ;Get TDP
1324      P:01E4 568203  [2 -      944]            TST     A         X:Y_T,A                 ;Check TDP, get Y
1325      P:01E5 022048  [2 -      946]            TNE     X0,B                              ;If TDP!=0 set AX=1
1326      P:01E6 458355  [2 -      948]            CMP     Y0,A      X:AP_T,X1               ;Check for Y<"3", get AP
1327      P:01E7 029048  [2 -      950]            TLT     X0,B                              ;If Y<"3" set AX=1
1328   
1329                                     ;**************************************************************************
1330                                     ;       FILTC
1331                                     ;
1332                                     ; Low pass filter of speed control parameter
1333                                     ;
1334                                     ; AP(k) = (1-2**(-4)) * AP(k-1) + AX
1335                                     ;
1336                                     ; Inputs:
1337                                     ;   AX = 0i0.0 0000 | 0000 0000 | 0000 0000  (1SM)
1338                                     ;   AP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
1339                                     ;
1340                                     ; Outputs:
1341                                     ;   APP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
1342                                     ;
1343                                     ;**************************************************************************
1344   
1345      P:01E8 4EA46C  [2 -      952]            SUB     X1,B                  Y:RSHFT+4,Y0 ;Find DIF=AX-AP
1346      P:01E9 21A400  [2 -      954]            MOVE              B1,X0
1347      P:01EA 4CDFD0  [2 -      956]            MPY     X0,Y0,A               Y:(R7)+,X0  ;Find DIFSX=DIF>>4, get K29
1348      P:01EB 5F8E46  [2 -      958]            AND     X0,A                  Y:TR_T,B    ;Truncate DIFSX, get TR
1349      P:01EC 242060  [2 -      960]            ADD     X1,A      #<$20,X0                ;Find APP=DIFSX+AP, get '1'
1350   
1351                                     ;**************************************************************************
1352                                     ;       TRIGA
1353                                     ;
1354                                     ; Speed control trigger block
1355                                     ;
1356                                     ; AP(k) = AP(k) if TR(k)=0
1357                                     ;       =  1    if TR(k)=1
1358                                     ;
1359                                     ; Inputs:
1360                                     ;   TR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1361                                     ;   APP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
1362                                     ;
1363                                     ; Outputs:
1364                                     ;   APR = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
1365                                     ;
1366                                     ;**************************************************************************
1367   
1368      P:01ED 458B0B  [2 -      962]            TST     B         X:IMAG,X1               ;Check TR, get IMAG
1369      P:01EE 02B040  [2 -      964]            TMI     X0,A                              ;If TR=1 set APR=1, else APR=APP
1370      P:01EF 540300  [2 -      966]            MOVE              A1,X:AP_T               ;Save APR to AP
1371   
1372                                     ;**************************************************************************
1373                                     ;       FUNCTW
1374                                     ;
1375                                     ; Map quantizer output into logarithmic version of scale
1376                                     ;  factor multiplier






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 26



1377                                     ;
1378                                     ;  |I(k)|  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
1379                                     ; ---------+-----+-----+-----+-----+-----+-----+-----+-----+
1380                                     ;   W(I)   |70.13|22.19|12.38| 7.00| 4.00| 2.56| 1.13|-0.75|
1381                                     ;
1382                                     ; Inputs:
1383                                     ;   I = siii. 0000 | 0000 0000 | 0000 0000  (ADPCM format)
1384                                     ;
1385                                     ; Outputs:
1386                                     ;   WI = siii iiii. | ffff 0000 | 0000 0000  (12TC)
1387                                     ;
1388                                     ;**************************************************************************
1389   
1390      P:01F0 4CB400  [2 -      968]            MOVE                          Y:RSHFT+20,X0 ;Get shift constant
1391      P:01F1 3020A0  [2 -      970]            MPY     X0,X1,A   #WIBASE,R0              ;Shift IM=IMAG for lookup,
1392                                                                                         ; load lookup table base
1393      P:01F2 219800  [2 -      972]            MOVE              A1,N0                   ;Load IM as offset
1394      P:01F3 4DA300  [2 -      974]            MOVE                          Y:RSHFT+3,X1 ;Get shift constant
1395      P:01F4 468200  [2 -      976]            MOVE              X:Y_T,Y0                ;Get Y
1396      P:01F5 56E8E8  [4 -      980]            MPY     Y0,X1,B   X:(R0+N0),A             ;Shift Y>>3,
1397                                                                                         ; get WI from lookup table
1398   
1399                                     ;**************************************************************************
1400                                     ;       FILTD
1401                                     ;
1402                                     ; Update of fast quantizer scale factor
1403                                     ;
1404                                     ; YU(k) = (1 - 2**(-5)) * Y(k) + 2**(-5) * W[I(k)]
1405                                     ;
1406                                     ; Inputs:
1407                                     ;   WI =  siii iiii. | ffff 0000 | 0000 0000  (12TC)
1408                                     ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1409                                     ;
1410                                     ; Outputs:
1411                                     ;   YUT = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1412                                     ;
1413                                     ;**************************************************************************
1414   
1415      P:01F6 200014  [2 -      982]            SUB     B,A                               ;Find DIF=WI-Y
1416      P:01F7 200022  [2 -      984]            ASR     A                                 ;Find DIFSX=DIF>>5 (actually DIF>>2)
1417      P:01F8 4CDF22  [2 -      986]            ASR     A                     Y:(R7)+,X0  ;Get mask K30
1418      P:01F9 200046  [2 -      988]            AND     X0,A                              ;Truncate DIFSX
1419      P:01FA 245050  [2 -      990]            ADD     Y0,A      #<$50,X0                ;Find YUT=DIFSX+Y,
1420                                                                                         ; get upper limit '10'
1421   
1422                                     ;**************************************************************************
1423                                     ;       LIMB
1424                                     ;
1425                                     ; Limit quantizer scale factor
1426                                     ;
1427                                     ; 1.06 <= YU(k) <= 10.00
1428                                     ;
1429                                     ; Inputs:
1430                                     ;   YUT = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1431                                     ;
1432                                     ; Outputs:






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 27



1433                                     ;   YUP = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1434                                     ;
1435                                     ;**************************************************************************
1436   
1437      P:01FB 4DDF45  [2 -      992]            CMP     X0,A                  Y:(R7)+,X1  ;Check for YU>10,
1438                                                                                         ; get lower limit '1.06' (K31)
1439      P:01FC 027040  [2 -      994]            TGT     X0,A                              ;If YU>10 set YU=10
1440      P:01FD 4F8B65  [2 -      996]            CMP     X1,A                  Y:YL_T,Y1   ;Check for YU<1.06, get YL
1441      P:01FE 029060  [2 -      998]            TLT     X1,A                              ;If YU<1.06 set YU=1.06
1442   
1443                                     ;**************************************************************************
1444                                     ;       FILTE
1445                                     ;
1446                                     ; Update of slow quantizer scale factor
1447                                     ;
1448                                     ; YL(k) = (1 - 2**(-6)) * YL(k-1) + 2**(-6) * YU(k)
1449                                     ;
1450                                     ; Inputs:
1451                                     ;   YUP = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1452                                     ;   YL = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
1453                                     ;
1454                                     ; Outputs:
1455                                     ;   YLP = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
1456                                     ;
1457                                     ;**************************************************************************
1458   
1459      P:01FF 5C0A79  [2 -     1000]            TFR     Y1,B                  A1,Y:YU_T   ;Move YL, save YUP
1460      P:0200 4EDF3E  [2 -     1002]            NEG     B                     Y:(R7)+,Y0  ;Find -YL, save YL, get mask K32
1461      P:0201 20005E  [2 -     1004]            AND     Y0,B                              ;Truncate -YL (-YL>>6)
1462      P:0202 4EA610  [2 -     1006]            ADD     B,A                   Y:RSHFT+6,Y0 ;Find DIF=YUP+(-YL>>6)
1463      P:0203 218500  [2 -     1008]            MOVE              A1,X1
1464      P:0204 2000E0  [2 -     1010]            MPY     Y0,X1,A                           ;Find DIFSX>>6
1465      P:0205 620E70  [2 -     1012]            ADD     Y1,A      R2,X:DATAPTR_T          ;Find YLP=DIFSX+YL,
1466                                                                                         ; save transmit data pointer
1467      P:0206 5C0B00  [2 -     1014]            MOVE                          A1,Y:YL_T   ;Save YL
1468   
1469                                     ;**************************************************************************
1470                                     ;
1471                                     ;   Decoder
1472                                     ;
1473                                     ;**************************************************************************
1474   
1475      P:0207 317800  [2 -     1016]  DECODE    MOVE              #PP_R,R1                ;Set partial product ptr to WB1
1476      P:0208 628F00  [2 -     1018]            MOVE              X:DATAPTR_R,R2          ;Set data pointer to DQ1EXP
1477      P:0209 366000  [2 -     1020]            MOVE              #COEF_R,R6              ;Set coef pointer to B1
1478      P:020A 373800  [2 -     1022]            MOVE              #CONST1,R7              ;Set pointer to misc constants
1479   
1480                                     ;**************************************************************************
1481                                     ;       FMULT
1482                                     ;
1483                                     ; Multiply predictor coefficients with corresponding
1484                                     ;   quantized difference signal or reconstructed signal
1485                                     ;
1486                                     ;   Data (DQn or SRn) is stored in 11FL format (separate),
1487                                     ;   & coefficient (Bn or An) is stored in 16TC format.
1488                                     ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 28



1489                                     ; Computes  [An(k-1) * SR(k-n)] or [Bn(k-1) * DQ(k-n)]
1490                                     ;
1491                                     ; Flow Description:
1492                                     ;   1. Convert 16TC An to 13SM AnMAG
1493                                     ;   2. Convert 13SM AnMAG to 10FL (AnEXP and AnMANT)
1494                                     ;   3. Add SRnEXP to AnEXP to get WAnEXP (5-bits)
1495                                     ;   4. Multiply SRnMANT with AnMANT, add '48', and truncate
1496                                     ;       to 8-bits to get WAnMANT
1497                                     ;   5. Convert 13FL (WAnEXP & WAnMANT) to 15SM WAnMAG
1498                                     ;   6. XOR AnS with SRnS to find WAnS
1499                                     ;   7. Convert 16SM (WAnMAG & WAnS) to 16TC WAn
1500                                     ;
1501                                     ; Input:
1502                                     ;   SRn = (11FL)
1503                                     ;    SRnEXP = X:(R2) = 0000 0000 | 0000 0000 | 0000 eeee
1504                                     ;    SRnMANT = X:(R2+1) = 01mm mmm0 | 0000 0000 | 0000 0000
1505                                     ;    SRnS = X:(R2+2) = sXXX XXXX | XXXX XXXX | 0000 0000
1506                                     ;       (DQ in same format as SR)
1507                                     ;
1508                                     ;   An = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1509                                     ;       (Bn in same format as An)
1510                                     ;
1511                                     ; Output:
1512                                     ;   WAn = X:(R1) = siii iiii | iiii iii.f | 0000 0000  (16TC)
1513                                     ;       (WBn in same format as WAn)
1514                                     ;
1515                                     ;**************************************************************************
1516   
1517      P:020B 303000  [2 -     1024]            MOVE              #CONST,R0               ;Set pointer to FMULT constants
1518      P:020C 270000  [2 -     1026]            MOVE              #0,Y1
1519      P:020D 060880  [6 -     1032]            DO      #8,ACCUM_R                        ;Execute mult 8 times
                 00023A
1520   
1521                                     ; 1. Convert 16TC An to 13SM AnMAG
1522      P:020F C6D800  [2 -     1034]            MOVE              X:(R0)+,X1  Y:(R6),A    ;Get An and mask KF1
1523      P:0210 45D866  [2 -     1036]            AND     X1,A      X:(R0)+,X1              ;Truncate An to 13 bits (An>>2),
1524                                                                                         ; get mask KF2
1525      P:0211 340D26  [2 -     1038]            ABS     A         #$000D,R4               ;Find AnMAG, load
1526                                                                                         ; exponent bias (13) into R4
1527      P:0212 257E66  [2 -     1040]            AND     X1,A      #<$7E,X1                ;Truncate any ovrflw, get mask
1528                                     ;   A1 = 0i.ff ffff | ffff ff00 | 0000 0000 (A2=A0=0)
1529   
1530                                     ; 2. Convert 13SM AnMAG to 10FL (AnEXP and AnMANT)
1531      P:0213 0E2217  [4 -     1044]            JNE     <NORMAN_R                         ;Test AnMAG
1532      P:0214 2E4000  [2 -     1046]            MOVE              #<$40,A                 ;If AnMAG=0, set AnMANT=1<<5,
1533      P:0215 340000  [2 -     1048]            MOVE              #0,R4                   ; and AnEXP=0
1534      P:0216 0C0223  [4 -     1052]            JMP     <CONTIN_R
1535      P:0217 01DC15  [2 -     1054]  NORMAN_R  NORM    R4,A                              ;If AnMAG!=0 do NORM iteration
1536      P:0218 01DC15  [2 -     1056]            NORM    R4,A                              ; 12 times to find MSB
1537      P:0219 01DC15  [2 -     1058]            NORM    R4,A
1538      P:021A 01DC15  [2 -     1060]            NORM    R4,A
1539      P:021B 01DC15  [2 -     1062]            NORM    R4,A
1540      P:021C 01DC15  [2 -     1064]            NORM    R4,A
1541      P:021D 01DC15  [2 -     1066]            NORM    R4,A
1542      P:021E 01DC15  [2 -     1068]            NORM    R4,A
1543      P:021F 01DC15  [2 -     1070]            NORM    R4,A






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 29



1544      P:0220 01DC15  [2 -     1072]            NORM    R4,A
1545      P:0221 01DC15  [2 -     1074]            NORM    R4,A
1546      P:0222 01DC15  [2 -     1076]            NORM    R4,A
1547                                     ;   A1 = 01?? ???? | ???? ??00 | 0000 0000 = AnMANT
1548                                     ;   R4 = 0000 0000 | 0000 eeee = AnEXP
1549      P:0223 228F66  [2 -     1078]  CONTIN_R  AND     X1,A      R4,B                    ;Truncate AnMANT to 6 bits,
1550                                                                                         ; move AnEXP to B
1551                                     ;   A1 = 01mm mmm0 | 0000 0000 | 0000 0000 (A2=A0=0)
1552                                     ;   B1 = 0000 0000 | 0000 0000 | 0000 eeee (B2=B0=0)
1553   
1554                                     ; 3. Add SRnEXP to AnEXP to get WAnEXP (5-bits)
1555      P:0224 149A00  [2 -     1080]            MOVE              X:(R2)+,X1  A,Y0        ;Get SRnEXP
1556      P:0225 45DA68  [2 -     1082]            ADD     X1,B      X:(R2)+,X1              ;Find WAnEXP=SRnEXP+AnEXP,
1557                                                                                         ; get SRnMANT 
1558                                     ;   B1 = 0000 0000 | 0000 0000 | 000e eeee (B2=B0=0)
1559   
1560                                     ; 4. Multiply SRnMANT with AnMANT, add '48', and truncate
1561                                     ;       to 8-bits to get WAnMANT
1562                                     ;   Y0 = 01mm mmm0 | 0000 0000 | 0000 0000
1563                                     ;   X1 = 01mm mmm0 | 0000 0000 | 0000 0000
1564      P:0226 44D8E0  [2 -     1084]            MPY     Y0,X1,A   X:(R0)+,X0              ;Find WAnMANT, get '48' (KF3)
1565                                     ;   A1 = 0mmm mmmm | mmmm m000 | 0000 0000 (A2=A0=0)
1566                                     ;   X0 = 0000 0001 | 1000 0000 | 0000 0000 = '48'
1567      P:0227 44D840  [2 -     1086]            ADD     X0,A      X:(R0)+,X0              ;Add '48' to WAnMANT, get mask KF4
1568      P:0228 44D846  [2 -     1088]            AND     X0,A      X:(R0)+,X0              ;Truncate WAnMANT to 8 bits,
1569                                                                                         ; get '26' (KF5)
1570                                     ;   A1 = 0mmm mmmm | m000 0000 | 0000 0000 (A2=A0=0)
1571   
1572                                     ; 5. Convert 13FL (WAnEXP & WAnMANT) to 15SM WAnMAG
1573                                     ;   X0 = 0000 0000 | 0000 0000 | 0001 1010 = '26'
1574                                     ;   B1 = 0000 0000 | 0000 0000 | 000e eeee (B2=B0=0) 
1575      P:0229 44D84C  [2 -     1090]            SUB     X0,B      X:(R0)+,X0              ;Find shift offset (WAnEXP-26),
1576                                                                                         ; get mask KF6
1577      P:022A 0EA236  [4 -     1094]            JEQ     <TRUNC_R                          ;If offset=26 no shift
1578      P:022B 0EB22F  [4 -     1098]            JMI     <RIGHT_R                          ;If offset<26 do right shift
1579                                                                                         ;Else offset>26, do left shift
1580      P:022C 06CD20  [4 -     1102]            REP     B1                                ;Offset>26, shift WAnMANT
1581      P:022D 200033  [2 -     1104]            LSL     A                                 ; left up to 4 times
1582      P:022E 0C0236  [4 -     1108]            JMP     <TRUNC_R
1583      P:022F 46F42E  [4 -     1112]  RIGHT_R   ABS     B         #>$0F,Y0                ;Find |offset|, get '15'
                 00000F
1584      P:0231 21BD5D  [2 -     1114]            CMP     Y0,B      B1,N5                   ;Compare |offset| to '15',
1585                                                                                         ; load offset for shift
1586      P:0232 021070  [2 -     1116]            TGE     Y1,A                              ;If |offset|>=15 WAnMAG=0
1587      P:0233 218500  [2 -     1118]            MOVE              A1,X1                   ;Move WAnMANT for shift
1588      P:0234 4EED00  [4 -     1122]            MOVE                          Y:(R5+N5),Y0 ;Lookup shift constant
1589      P:0235 2000E0  [2 -     1124]            MPY     Y0,X1,A                           ;Shift WAnMANT right up to 14 times
1590                                     ;   A1 = ?mmm mmmm | mmmm mmmm | ???? ???? (A2=A0=0)
1591      P:0236 F7DA46  [2 -     1126]  TRUNC_R   AND     X0,A      X:(R2)+,X1  Y:(R6)+,B   ;Truncate WAnMAG to 15 bits,
1592                                                                                         ; get SRnS & AnS
1593                                     ;   A1 = 0iii iiii | iiii iii.f | 0000 0000 (A2=A0=0)
1594      P:0237 218436  [2 -     1128]            NEG     A         A1,X0                   ;Find -WAnMAG, save WAnMAG
1595   
1596                                     ; 6. XOR AnS with SRnS to find WAnS
1597                                     ;   B1 = sXXX XXXX | XXXX XXXX | 0000 0000 (B2=sign ext, B0=0)
1598                                     ;   X1 = sXXX XXXX | XXXX XXXX | 0000 0000






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 30



1599      P:0238 30306B  [2 -     1130]            EOR     X1,B      #CONST,R0               ;Find WAnS (in MSB of B),
1600                                                                                         ; update pointer to constants
1601   
1602                                     ; 7. Convert 16SM (WAnMAG & WAnS) to 16TC WAn
1603      P:0239 023040  [2 -     1132]            TPL     X0,A                              ;If WAnS=0 use WAnMAG, else use -WAnMAG
1604                                     ;   A1 = siii iiii | iiii iii.f | 0000 0000  (A2=sign ext, A0=0)
1605      P:023A 545900  [2 -     1134]            MOVE              A1,X:(R1)+              ;Save WAn
1606   
1607                                     ;**************************************************************************
1608                                     ;       ACCUM
1609                                     ;
1610                                     ; Add predictor outputs to form the partial signal estimate
1611                                     ;   and the signal estimate
1612                                     ;
1613                                     ; SEZ(k) = [B1(k-1) * DQ(k-1)] + ... + [B6(k-1) * DQ(k-6)]
1614                                     ;        = WB1 + WB2 + ... + WB6
1615                                     ;
1616                                     ; SE(k) = SEZ(k) + [A1(k-1) * SR(k-1)] + [A2(k-1) * SR(k-2)]
1617                                     ;       = SEZ + WA1 + WA2
1618                                     ;
1619                                     ; Inputs:
1620                                     ;   WBn & WAn = X:(R1) = siii iiii | iiii iii.f | 0000 0000  (16TC)
1621                                     ;
1622                                     ; Outputs:
1623                                     ;   SEZ = siii iiii | iiii iii.0 | 0000 0000  (15TC)
1624                                     ;   SE = siii iiii | iiii iii.0 | 0000 0000  (15TC)
1625                                     ;
1626                                     ;**************************************************************************
1627   
1628      P:023B 56D900  [2 -     1136]  ACCUM_R   MOVE              X:(R1)+,A               ;Get WB1
1629      P:023C 44D900  [2 -     1138]            MOVE              X:(R1)+,X0              ;Get WB2
1630      P:023D 44D940  [2 -     1140]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB1&WB2, get WB3
1631      P:023E 44D940  [2 -     1142]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB3, get WB4
1632      P:023F 44D940  [2 -     1144]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB4, get WB5
1633      P:0240 44D940  [2 -     1146]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB5, get WB6
1634      P:0241 44D940  [2 -     1148]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WB6 to get SEZI, get WA1
1635      P:0242 4DDF09  [2 -     1150]            TFR     A,B                   Y:(R7)+,X1  ;Copy SEZI, get mask K1
1636      P:0243 46886E  [2 -     1152]            AND     X1,B      X:AP_R,Y0               ;Truncate SEZI, get AP
1637      P:0244 44D940  [2 -     1154]            ADD     X0,A      X:(R1)+,X0              ;Accumulate WA1, get WA2
1638      P:0245 5D1040  [2 -     1156]            ADD     X0,A                  B1,Y:SEZ_R  ;Accumulate WA2 to get SEI, save SEZ
1639      P:0246 242066  [2 -     1158]            AND     X1,A      #<$20,X0                ;Truncate SEI, get '1'
1640      P:0247 5C0F51  [2 -     1160]            TFR     Y0,A                  A1,Y:SE_R   ;Move AP, save SE
1641   
1642                                     ;**************************************************************************
1643                                     ;       LIMA
1644                                     ;
1645                                     ; Limit speed control parameter
1646                                     ;
1647                                     ; AL(k) = 1        if AP(k-1) > 1
1648                                     ;       = AP(k-1)  if AP(k-1) <= 1
1649                                     ;
1650                                     ; Inputs:
1651                                     ;   AP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
1652                                     ;
1653                                     ; Outputs:
1654                                     ;   AL = 0i.ff ffff | 0000 0000 | 0000 0000  (7SM)






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 31



1655                                     ;
1656                                     ;**************************************************************************
1657   
1658      P:0248 5F9A45  [2 -     1162]            CMP     X0,A                  Y:YL_R,B    ;Test AP, get YL
1659      P:0249 027040  [2 -     1164]            TGT     X0,A                              ;If AP>'1' set AL='1'
1660      P:024A 247F33  [2 -     1166]            LSL     A         #<$7F,X0                ;Shift to align radix pt., get mask
1661      P:024B 4CDF46  [2 -     1168]            AND     X0,A                  Y:(R7)+,X0  ;Truncate AL (AP>>2), get mask K2
1662   
1663                                     ;**************************************************************************
1664                                     ;       MIX
1665                                     ;
1666                                     ; Form linear combination of fast and slow quantizer
1667                                     ;   scale factors
1668                                     ;
1669                                     ; Y(k) = AL(k) * YU(k-1) + [1 - AL(k)] * YL(k-1)
1670                                     ;
1671                                     ; Inputs:
1672                                     ;   YL = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
1673                                     ;   AL = 0i.ff ffff | 0000 0000 | 0000 0000  (7SM)
1674                                     ;   YU = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1675                                     ;
1676                                     ; Outputs:
1677                                     ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1678                                     ;
1679                                     ;**************************************************************************
1680   
1681      P:024C 12F04E  [4 -     1172]            AND     X0,B      A,X0        Y:YU_R,A    ;Truncate YL (YL>>6), get YU
                 000019
1682      P:024E 133014  [4 -     1176]            SUB     B,A       B,Y1        X0,X:AL_R   ;Find DIF=YU-YL, save YL, get AL
                 000009
1683      P:0250 21CF26  [2 -     1178]            ABS     A         A,B                     ;Find DIFM=|DIF|, save DIFS
1684      P:0251 218600  [2 -     1180]            MOVE              A1,Y0
1685      P:0252 4CDFD0  [2 -     1182]            MPY     X0,Y0,A               Y:(R7)+,X0  ;Find DIFM*AL, get mask K3
1686      P:0253 200046  [2 -     1184]            AND     X0,A                              ;Truncate to find PRODM=(DIFM*AL)>>6
1687      P:0254 218436  [2 -     1186]            NEG     A         A1,X0                   ;Find -PRODM, save PRODM
1688      P:0255 20000B  [2 -     1188]            TST     B                                 ;Check DIFS
1689      P:0256 023040  [2 -     1190]            TPL     X0,A                              ;If DIFS=0 PROD=PRODM,
1690                                                                                         ; else PROD=-PRODM
1691      P:0257 20EF32  [2 -     1192]            ASL     A         Y1,B                    ;Line up radix point
1692      P:0258 200070  [2 -     1194]            ADD     Y1,A                              ;Find Y=PROD+(YL>>6)
1693      P:0259 560700  [2 -     1196]            MOVE              A,X:Y_R                 ;Save Y
1694   
1695                                     ;**************************************************************************
1696                                     ;
1697                                     ; Input ADPCM data (I) here. For simulation purposes the Input 
1698                                     ; Word from File subroutine on the 56001 ADS board is used.
1699                                     ;
1700                                     ;**************************************************************************
1701   
1702      P:025A 240200  [2 -     1198]            MOVE              #2,X0                   ;Input ADPCM word (I)
1703      P:025B 0BF080  [6 -     1204]            JSR     $E002
                 00E002
1704   
1705                                     ;**************************************************************************
1706                                     ;       RECONST
1707                                     ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 32



1708                                     ; Reconstruct quantized difference signal in the log domain
1709                                     ;
1710                                     ;     |I(k)| | log2|DQ(k)| - Y(k)
1711                                     ;    --------+-------------------
1712                                     ;       7    |      3.32
1713                                     ;       6    |      2.91
1714                                     ;       5    |      2.52
1715                                     ;       4    |      2.13
1716                                     ;       3    |      1.66
1717                                     ;       2    |      1.05
1718                                     ;       1    |      0.031
1719                                     ;       0    |      - inf
1720                                     ;
1721                                     ; Inputs:
1722                                     ;   I = iiii 0000 | 0000 0000 | 0000 0000  (ADPCM format)
1723                                     ;
1724                                     ; Output:
1725                                     ;   DQLN = siii i.fff | ffff 0000 | 0000 0000  (12TC)
1726                                     ;   DQS = sXXX 0000 | 0000 0000 | 0000 0000  (1TC)
1727                                     ;
1728                                     ;**************************************************************************
1729   
1730      P:025D 25F000  [2 -     1206]            MOVE              #<$F0,X1
1731      P:025E 193000  [4 -     1210]            MOVE              A,Y1        A,X:I_R     ;Save DQS (sign of I) to Y1
                 000005
1732      P:0260 4EB463  [2 -     1212]            EOR     X1,A                  Y:RSHFT+20,Y0 ;Invert bits of I
1733      P:0261 02B070  [2 -     1214]            TMI     Y1,A                              ;If ^IS=1, use I, else use ^I
1734                                     ;   A1 = 0iii 0000 | 0000 0000 | 0000 0000 (A2=?, A0=0)
1735      P:0262 218400  [2 -     1216]            MOVE              A1,X0
1736      P:0263 540B00  [2 -     1218]            MOVE              A1,X:IMAG               ;Save |I|
1737      P:0264 3418D0  [2 -     1220]            MPY     X0,Y0,A   #IQUANTAB,R4            ;Shift IMAG>>20
1738                                     ;   A1 = 0000 0000 | 0000 0000 | 0000 0iii (A2=A0=0)
1739      P:0265 219C00  [2 -     1222]            MOVE              A1,N4                   ;Load IMAG as offset
1740      P:0266 578700  [2 -     1224]            MOVE              X:Y_R,B                 ; into IQUAN table, get Y
1741      P:0267 373F00  [2 -     1226]            MOVE              #CONST8,R7              ;Adjust constant pointer
1742      P:0268 56EC00  [4 -     1230]            MOVE              X:(R4+N4),A             ;Lookup DQLN
1743   
1744                                     ;**************************************************************************
1745                                     ;       ADDA
1746                                     ;
1747                                     ; Add scale factor to log version of quantized difference
1748                                     ;   signal
1749                                     ;
1750                                     ; DQL = DQLN + Y
1751                                     ;
1752                                     ; Inputs:
1753                                     ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
1754                                     ;   DQLN = siii i.fff | ffff 0000 | 0000 0000  (12TC)
1755                                     ;
1756                                     ; Output:
1757                                     ;   DQL = siii i.fff | ffff 0000 | 0000 0000  (12TC)
1758                                     ;
1759                                     ;**************************************************************************
1760   
1761      P:0269 4EDF00  [2 -     1232]            MOVE                          Y:(R7)+,Y0  ;Get mask K8 for ADDA
1762      P:026A 4CDF5E  [2 -     1234]            AND     Y0,B                  Y:(R7)+,X0  ;Truncate Y to 11 bits (Y<<2),






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 33



1763                                                                                         ; get mask K9
1764      P:026B 250810  [2 -     1236]            ADD     B,A       #<$08,X1                ;Find DQL=DQLN+(Y<<2), get '1'
1765   
1766                                     ;**************************************************************************
1767                                     ;       ANTILOG
1768                                     ;
1769                                     ; Convert quantized difference signal from log to linear
1770                                     ;   domain
1771                                     ;
1772                                     ; Input:
1773                                     ;   DQL = siii i.fff | ffff 0000 | 0000 0000  (12TC)
1774                                     ;   DQS = sXXX 0000 | 0000 0000 | 0000 0000  (1TC)
1775                                     ;
1776                                     ; Outputs:
1777                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
1778                                     ;
1779                                     ;**************************************************************************
1780   
1781      P:026C 0E3273  [4 -     1240]            JPL     <CONVLOG_R                        ;If DQL>=0 (DS=0) convert DQL,
1782                                                                                         ; else DQL<0 (DS=1), set |DQ|=0
1783      P:026D 248071  [2 -     1242]            TFR     Y1,A      #<$80,X0                ;Get DQS (MSB of I), get mask
1784      P:026E 2F0046  [2 -     1244]            AND     X0,A      #0,B                    ;Mask off DQS, set |DQ|=0
1785                                     ;   A1 = s000 0000 | 0000 0000 | 0000 0000  (A2=sign ext, A0=0)
1786      P:026F 5D1F00  [2 -     1246]            MOVE                          B1,Y:DQMAG  ;Save DQMAG=|DQ|
1787      P:0270 205F00  [2 -     1248]            MOVE              (R7)+                   ;Adjust constant pointer
1788      P:0271 205F00  [2 -     1250]            MOVE              (R7)+
1789      P:0272 0C0287  [4 -     1254]            JMP     <SAVEDQ_R
1790   
1791      P:0273 21CF46  [2 -     1256]  CONVLOG_R AND     X0,A      A,B                     ;Find fractional part (DMN),
1792                                                                                         ; save DS
1793                                     ;   A1 = 0000 0.fff | ffff 0000 | 0000 0000  (A2=A0=0)
1794      P:0274 247862  [2 -     1258]            OR      X1,A      #<$78,X0                ;Add implied '1' to DMN to
1795                                                                                         ; find DQT, get integer mask
1796                                     ;   A1 = 0000 1.fff | ffff 0000 | 0000 0000  (A2=A0=0)
1797      P:0275 4EB34E  [2 -     1260]            AND     X0,B                  Y:RSHFT+19,Y0 ;Find integer part (DEX),
1798                                                                                         ; get shift constant
1799                                     ;   B1 = 0iii i.000 | 0000 0000 | 0000 0000  (B2=B0=0)
1800      P:0276 21A400  [2 -     1262]            MOVE              B1,X0
1801      P:0277 4CDFD8  [2 -     1264]            MPY     X0,Y0,B               Y:(R7)+,X0  ;Shift DEX>>19, get '10' (K10)
1802                                     ;   A1 = 0000 1.fff | ffff 0000 | 0000 0000  (A2=A0=0)
1803                                     ;   B1 = 0000 0000 | 0000 0000 | 0000 iiii.  (B2=B0=0)
1804      P:0278 4CDF4C  [2 -     1266]            SUB     X0,B                  Y:(R7)+,X0  ;Find DQT shift=DEX-'10',
1805                                                                                         ; get mask K11
1806      P:0279 0EA283  [4 -     1270]            JEQ     <TRUNCDQM_R                       ;If DEX=10, no shift
1807      P:027A 0E927E  [4 -     1274]            JLT     <SHFRDQ_R                         ;If DEX<10, shift right
1808      P:027B 06CD20  [4 -     1278]            REP     B1                                ;Else shift DQT left
1809      P:027C 200033  [2 -     1280]            LSL     A                                 ; up to 4 times
1810      P:027D 0C0283  [4 -     1284]            JMP     <TRUNCDQM_R
1811   
1812      P:027E 20003E  [2 -     1286]  SHFRDQ_R  NEG     B                                 ;Find 10-DEX
1813      P:027F 21BD00  [2 -     1288]            MOVE              B1,N5                   ;Use 10-DEX for shift lookup
1814      P:0280 218600  [2 -     1290]            MOVE              A1,Y0
1815      P:0281 4DED00  [4 -     1294]            MOVE                          Y:(R5+N5),X1 ;Lookup shift constant
1816      P:0282 2000E0  [2 -     1296]            MPY     X1,Y0,A                           ;Shift DQT right up to 9 times
1817      P:0283 2F8046  [2 -     1298]  TRUNCDQM_R AND    X0,A      #<$80,B                 ;Truncate to find DQMAG=|DQ|,
1818                                                                                         ; get sign mask






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 34



1819                                     ;   A1 = 0iii iiii | iiii iii.0 | 0000 0000  (A2=A0=0)
1820      P:0284 5C1F7E  [2 -     1300]            AND     Y1,B                  A1,Y:DQMAG  ;Mask off DQS, save DQMAG           
1821                                     ;   B1 = s000 0000 | 0000 0000 | 0000 0000  (B2=?, B0=0)
1822      P:0285 21A400  [2 -     1302]            MOVE              B1,X0
1823      P:0286 200042  [2 -     1304]            OR      X0,A                              ;Add DQS to DQMAG to get DQ
1824                                     ;   A1 = siii iiii | iiii iii.0 | 0000 0000  (A2=?, A0=0)
1825      P:0287 540600  [2 -     1306]  SAVEDQ_R  MOVE              A1,X:DQ_R               ;Save DQ
1826   
1827                                     ;**************************************************************************
1828                                     ;       TRANS
1829                                     ;
1830                                     ; Transition detector
1831                                     ;
1832                                     ; TR(k) = 1 if TD(k)=1 and |DQ(k)|> 24 x 2**(YL(k))
1833                                     ;         0 otherwise
1834                                     ;
1835                                     ; Inputs:
1836                                     ;   TD = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1837                                     ;   YL = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
1838                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
1839                                     ;
1840                                     ; Output:
1841                                     ;   TR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1842                                     ;
1843                                     ;**************************************************************************
1844   
1845      P:0288 5E9800  [2 -     1308]            MOVE                          Y:TD_R,A    ;Get TD
1846      P:0289 2E0003  [2 -     1310]            TST     A         #0,A                    ;Check TD, set TR=0
1847      P:028A 0EA2A8  [4 -     1314]            JEQ     <SAVETR_R                         ;If TD=0 save TR=0
1848                                                                                         ; else test DQ and YL
1849      P:028B 5E9A00  [2 -     1316]            MOVE                          Y:YL_R,A    ;Get YL
1850      P:028C 4CDF09  [2 -     1318]            TFR     A,B                   Y:(R7)+,X0  ;Save YL, get mask K12
1851      P:028D 240846  [2 -     1320]            AND     X0,A      #<$08,X0                ;Find YLFRAC (YL>>10), get '1'
1852      P:028E 1DDF42  [2 -     1322]            OR      X0,A      B,X1        Y:(R7)+,Y1  ;Add implied '1' to YLFRAC,
1853                                                                                         ; get mask K13
1854      P:028F 4CDFF8  [2 -     1324]            MPY     Y1,X1,B               Y:(R7)+,X0  ;Find YLINT=YL>>15, get '8' (K14)
1855      P:0290 21AF00  [2 -     1326]            MOVE              B1,B                    ;Adjust sign extension
1856      P:0291 4CDF4D  [2 -     1328]            CMP     X0,B                  Y:(R7)+,X0  ;Compare YLINT to '8', get '5' (K15)
1857      P:0292 0E7299  [4 -     1332]            JGT     <MAXTHR_R                         ;If YLINT>8 set maximum THR2
1858      P:0293 20004C  [2 -     1334]            SUB     X0,B                              ;Find YLINT-5
1859      P:0294 0EA2A0  [4 -     1338]            JEQ     <SETDQTHR_R                       ;If YLINT=5 don't shift
1860      P:0295 0E929B  [4 -     1342]            JLT     <RSHFT_R                          ;If YLINT<5 shift right
1861   
1862      P:0296 06CD20  [4 -     1346]            REP     B1                                ;Else shift YLFRAC left
1863      P:0297 200033  [2 -     1348]            LSL     A                                 ; up to 3 times to get THR1
1864      P:0298 0C02A0  [4 -     1352]            JMP     <SETDQTHR_R
1865   
1866      P:0299 2E7C00  [2 -     1354]  MAXTHR_R  MOVE              #<$7C,A                 ;Set maximum THR2 (31<<9)
1867      P:029A 0C02A0  [4 -     1358]            JMP     <SETDQTHR_R
1868   
1869      P:029B 20003E  [2 -     1360]  RSHFT_R   NEG     B                                 ;Find 5-YLINT
1870      P:029C 21BD00  [2 -     1362]            MOVE              B1,N5                   ;Use 5-YLINT for shift lookup
1871      P:029D 218400  [2 -     1364]            MOVE              A1,X0
1872      P:029E 4DED00  [4 -     1368]            MOVE                          Y:(R5+N5),X1 ;Lookup shift constant
1873      P:029F 2000A0  [2 -     1370]            MPY     X0,X1,A                           ;Shift YLFRAC right up to ? times
1874                                                                                         ; to get THR1






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 35



1875      P:02A0 4CDF09  [2 -     1372]  SETDQTHR_R TFR    A,B                   Y:(R7)+,X0  ;Get mask K16
1876      P:02A1 20002B  [2 -     1374]            LSR     B                                 ;Find THR2>>1
1877      P:02A2 20004E  [2 -     1376]            AND     X0,B                              ;Truncate THR2>>1
1878      P:02A3 250010  [2 -     1378]            ADD     B,A       #0,X1                   ;Find THR2+(THR2>>1)
1879      P:02A4 200023  [2 -     1380]            LSR     A                                 ;Find (THR2+(THR2>>1)>>1
1880      P:02A5 4C9F46  [2 -     1382]            AND     X0,A                  Y:DQMAG,X0  ;Truncate to find DQTHR, get DQMAG
1881      P:02A6 2E8045  [2 -     1384]            CMP     X0,A      #<$80,A                 ;Compare DQMAG to DQTHR, set TR=1
1882      P:02A7 027060  [2 -     1386]            TGT     X1,A                              ;If DQMAG>DQTHR leave TR=1,
1883                                                                                         ; else DQMAG<=DQTHR, set TR=0
1884      P:02A8 5C1D00  [2 -     1388]  SAVETR_R  MOVE                          A1,Y:TR_R   ;Save TR
1885   
1886                                     ;**************************************************************************
1887                                     ;       ADDB
1888                                     ;
1889                                     ; Add quantized difference signal and signal estimate
1890                                     ;   to form reconstructed signal
1891                                     ;
1892                                     ; SR(k-n) = SE(k-n) + DQ(k-n)
1893                                     ;
1894                                     ; Inputs:
1895                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
1896                                     ;   SE = siii iiii | iiii iii.0 | 0000 0000  (15TC)
1897                                     ;
1898                                     ; Output:
1899                                     ;   SR = siii iiii | iiii iiii. | 0000 0000  (16TC)
1900                                     ;
1901                                     ;**************************************************************************
1902   
1903      P:02A9 5F8F00  [2 -     1390]            MOVE                          Y:SE_R,B    ;Get SE
1904      P:02AA 56862A  [2 -     1392]            ASR     B         X:DQ_R,A                ;Sign extend SE to get SEI, get DQS
1905      P:02AB 5E9F03  [2 -     1394]            TST     A                     Y:DQMAG,A   ;Check DQS, get DQMAG
1906      P:02AC 0E32AE  [4 -     1398]            JPL     <SHFTDQ_R                         ;If DQS=0 continue
1907      P:02AD 200036  [2 -     1400]            NEG     A                                 ;Convert DQ to 2's comp
1908      P:02AE 200022  [2 -     1402]  SHFTDQ_R  ASR     A                                 ;Sign extend DQ to get DQI
1909      P:02AF 374818  [2 -     1404]            ADD     A,B       #CONST17,R7             ;Find SR=DQ+SE, update const pointer
1910   
1911                                     ;**************************************************************************
1912                                     ;       ADDC
1913                                     ;
1914                                     ; Obtain sign of addition of the quantized difference
1915                                     ;   signal and the partial signal estimate
1916                                     ;
1917                                     ; P(k) = DQ(k) + SEZ(k)
1918                                     ; PK0 = sign of P(k)
1919                                     ;
1920                                     ; Inputs:
1921                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000  (15SM)
1922                                     ;   SEZ = siii iiii | iiii iii.0 | 0000 0000 (15TC)
1923                                     ;
1924                                     ; Output:
1925                                     ;   PK0 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
1926                                     ;   SIGPK = i000 0000 | 0000 0000 | 0000 0000  (1TC)
1927                                     ;
1928                                     ;**************************************************************************
1929   
1930      P:02B0 5D1100  [2 -     1406]            MOVE                          B1,Y:SR_R   ;Save SR






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 36



1931      P:02B1 5F9000  [2 -     1408]            MOVE                          Y:SEZ_R,B   ;Get SEZ
1932      P:02B2 20002A  [2 -     1410]            ASR     B                                 ;Sign extend SEZ to SEZI
1933      P:02B3 2F0010  [2 -     1412]            ADD     B,A       #0,B                    ;Find DQSEZ=DQ+SEZ,
1934                                                                                         ; set SIGPK=0
1935      P:02B4 248003  [2 -     1414]            TST     A         #<$80,X0                ;Check DQSEZ, get '1'
1936      P:02B5 02A048  [2 -     1416]            TEQ     X0,B                              ;If DQSEZ=0, SIGPK=1,
1937                                                                                         ; else SIGPK=0
1938   
1939      P:02B6 4C9300  [2 -     1418]            MOVE                          Y:PK1_R,X0
1940      P:02B7 4C1400  [2 -     1420]            MOVE                          X0,Y:PK2_R  ;Delay previous PK1
1941      P:02B8 4C9200  [2 -     1422]            MOVE                          Y:PK0_R,X0
1942      P:02B9 4C1300  [2 -     1424]            MOVE                          X0,Y:PK1_R  ;Delay previous PK0
1943      P:02BA 5C1200  [2 -     1426]            MOVE                          A1,Y:PK0_R  ;Save new PK0
1944      P:02BB 5D1B00  [2 -     1428]            MOVE                          B1,Y:SIGPK_R ;Save SIGPK
1945      P:02BC 4C9443  [2 -     1430]            EOR     X0,A                  Y:PK2_R,X0  ;Find PKS1=PK0**PK1
1946                                                                                         ; for UPA1 & UPA2
1947      P:02BD 540C00  [2 -     1432]            MOVE              A1,X:PKS1               ;Save PKS1
1948      P:02BE 5E9200  [2 -     1434]            MOVE                          Y:PK0_R,A
1949      P:02BF 3A0343  [2 -     1436]            EOR     X0,A      #3,N2                   ;Find PKS2=PK0**PK2 for UPA2
1950      P:02C0 540D00  [2 -     1438]            MOVE              A1,X:PKS2               ;Save PKS2
1951      P:02C1 205A00  [2 -     1440]            MOVE              (R2)+                   ;Adjust data buffer pointer so
1952      P:02C2 205A00  [2 -     1442]            MOVE              (R2)+                   ; that R2 points to DQ1S
1953   
1954                                     ;**************************************************************************
1955                                     ;       XOR
1956                                     ;
1957                                     ; Find one bit "exclusive or" of the sign of difference
1958                                     ;   signal and the sign of delayed difference signal.
1959                                     ;
1960                                     ; Un = sgn[DQ(k)] XOR sgn[DQ(k-n)]
1961                                     ;
1962                                     ; Inputs:
1963                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000 (15SM)
1964                                     ;   DQnS = X:(R2+n) sXXX XXXX | XXXX XXXX | 0000 0000
1965                                     ;
1966                                     ; Outputs:
1967                                     ;   Un = sXXX XXXX | XXXX XXXX | 0000 0000 (1TC)
1968                                     ;
1969                                     ;**************************************************************************
1970                                     ;**************************************************************************
1971                                     ;       UPB
1972                                     ;
1973                                     ; Update the coefficients of the sixth order predictor
1974                                     ;
1975                                     ; Bn(k) = [1-(2**-8)] * Bn(k-1)
1976                                     ;           + (2**-7) * sgn[DQ(k)] * sgn[DQ(k-n)]
1977                                     ;
1978                                     ; Inputs:
1979                                     ;   Bn = Y:(R6+n) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1980                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000 (15SM)
1981                                     ;   Un = sXXX XXXX | XXXX XXXX | 0000 0000 (1TC)
1982                                     ;
1983                                     ; Outputs:
1984                                     ;   BnP = Y:(R6+n) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
1985                                     ;
1986                                     ;**************************************************************************






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 37



1987   
1988      P:02C3 5E9F00  [2 -     1444]            MOVE                          Y:DQMAG,A   ;Get DQMAG
1989      P:02C4 468603  [2 -     1446]            TST     A         X:DQ_R,Y0               ;Check DQMAG, get DQS
1990      P:02C5 0E22D3  [4 -     1450]            JNE     <XORUPB_R                         ;If DQMAG!=0 use section with XOR,
1991                                                                                         ; else use section with no XOR
1992                                                                                         ; (because UGBn=0 if DQMAG=0)
1993   
1994                                     ; UPB without XOR
1995      P:02C6 4DA800  [2 -     1452]            MOVE                          Y:RSHFT+8,X1 ;Get shift constant
1996      P:02C7 205F00  [2 -     1454]            MOVE              (R7)+                   ;Adjust constant pointer
1997      P:02C8 205F00  [2 -     1456]            MOVE              (R7)+
1998      P:02C9 4CDF00  [2 -     1458]            MOVE                          Y:(R7)+,X0  ;Get mask K19
1999      P:02CA 060680  [6 -     1464]            DO      #6,ENDLOOP_R                      ;Do UPB for B1-B6
                 0002D1
2000      P:02CC C9CA00  [2 -     1466]            MOVE              X:(R2)+N2,A Y:(R6),Y1   ;Get Bn (& DQnS but don't use)
2001      P:02CD 2000F0  [2 -     1468]            MPY     X1,Y1,A                           ;Find Bn>>8
2002      P:02CE 200046  [2 -     1470]            AND     X0,A                              ;Truncate (Bn>>8)
2003      P:02CF 200036  [2 -     1472]            NEG     A                                 ;Find UBn=ULBn=-(Bn>>8)
2004      P:02D0 200070  [2 -     1474]            ADD     Y1,A                              ;Find BnP=Bn+UBn
2005      P:02D1 5C5E00  [2 -     1476]            MOVE                          A1,Y:(R6)+  ;Store BnP to Bn
2006      P:02D2 0C02E3  [4 -     1480]  ENDLOOP_R JMP     <UPA2_R
2007   
2008                                     ; UPB with XOR
2009      P:02D3 4CDF00  [2 -     1482]  XORUPB_R  MOVE                          Y:(R7)+,X0  ;Get +gain (K17)
2010      P:02D4 060680  [6 -     1488]            DO      #6,UPTR_R                         ;Do UPB and XOR for B1-B6
                 0002E0
2011      P:02D6 C9CA00  [2 -     1490]            MOVE              X:(R2)+N2,A Y:(R6),Y1   ;Get Bn & DQnS
2012      P:02D7 4DDF53  [2 -     1492]            EOR     Y0,A                  Y:(R7)+,X1  ;Find Un=DQS**DQnS (XOR),
2013                                                                                         ; get -gain (K18)
2014      P:02D8 023040  [2 -     1494]            TPL     X0,A                              ;If Un=0 set UGBn=+gain
2015      P:02D9 02B060  [2 -     1496]            TMI     X1,A                              ;If Un=1 set UGBn=-gain
2016      P:02DA 4DA800  [2 -     1498]            MOVE                          Y:RSHFT+8,X1 ;Get shift constant
2017      P:02DB 4DD7F8  [2 -     1500]            MPY     X1,Y1,B               Y:(R7)-,X1  ;Shift Bn>>8, get mask K19
2018      P:02DC 20006E  [2 -     1502]            AND     X1,B                              ;Truncate (Bn>>8)
2019      P:02DD 20003E  [2 -     1504]            NEG     B                                 ;Find ULBn=-(Bn>>8)
2020      P:02DE 200010  [2 -     1506]            ADD     B,A                               ;Find UBn=UGBn+ULBn
2021      P:02DF 200070  [2 -     1508]            ADD     Y1,A                              ;Find BnP=Bn+UBn
2022      P:02E0 5C5E00  [2 -     1510]            MOVE                          A1,Y:(R6)+  ;Store BnP to Bn
2023      P:02E1 205F00  [2 -     1512]  UPTR_R    MOVE              (R7)+                   ;Adjust constant pointer
2024      P:02E2 205F00  [2 -     1514]            MOVE              (R7)+
2025   
2026                                     ;**************************************************************************
2027                                     ;       UPA2
2028                                     ;
2029                                     ; Update the A2 coefficient of the second order predictor.
2030                                     ;
2031                                     ; A2(k) = [1-(2**-7)] * A2(k-1)
2032                                     ;           + (2**-7) * { sgn[P(k)] * sgn[P(k-2)]
2033                                     ;               - F[A1(k-1)] * sgn[P(k)] * sgn[P(k-1)] }
2034                                     ;
2035                                     ; F[A1(k)] = 4 * A1       if |A1|<=(2**-1)
2036                                     ;          = 2 * sgn(A1)  if |A1|>(2**-1)
2037                                     ;
2038                                     ; Inputs:
2039                                     ;   A1 = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2040                                     ;   A2 = Y:(R6+1) = si.ff ffff | ffff ffff | 0000 0000 (16TC)






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 38



2041                                     ;   SIGPK = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2042                                     ;   PK0 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
2043                                     ;   PK1 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
2044                                     ;   PK2 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
2045                                     ;     (Note: PKS1 & PKS2 have been previously calculated)
2046                                     ;
2047                                     ; Outputs:
2048                                     ;   A2T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2049                                     ;
2050                                     ;**************************************************************************
2051   
2052      P:02E3 568D00  [2 -     1516]  UPA2_R    MOVE              X:PKS2,A                ;Get PKS2=PK0**PK2
2053      P:02E4 261003  [2 -     1518]            TST     A         #<$10,Y0                ;Check PKS2, get '+1'
2054      P:02E5 27F000  [2 -     1520]            MOVE              #<$F0,Y1                ;Get '-1'
2055      P:02E6 023050  [2 -     1522]            TPL     Y0,A                              ;If PKS2=0, set UGA2A='+1'
2056      P:02E7 02B070  [2 -     1524]            TMI     Y1,A                              ;If PKS2=1, set UGA2A='-1'
2057      P:02E8 16DE00  [2 -     1526]            MOVE              A,X1        Y:(R6)+,A   ;Save UGA2A, get A1
2058      P:02E9 4EDF00  [2 -     1528]            MOVE                          Y:(R7)+,Y0  ;Get '+1.99' (K20)
2059      P:02EA 4FDF55  [2 -     1530]            CMP     Y0,A                  Y:(R7)+,Y1  ;Check A1, get '-1.99' (K21)
2060      P:02EB 027050  [2 -     1532]            TGT     Y0,A                              ;If A1>=1/2, set FA1='1.99'
2061      P:02EC 578C75  [2 -     1534]            CMP     Y1,A      X:PKS1,B                ;Check A1 again, get PKS1=PK0**PK1
2062      P:02ED 029070  [2 -     1536]            TLT     Y1,A                              ;If A1<=-1/2, set FA1='-1.99'
2063      P:02EE 24000B  [2 -     1538]            TST     B         #0,X0                   ;Check PKS1
2064      P:02EF 0EB2F1  [4 -     1542]            JMI     <FINDSUM_R                        ;If PKS1=1, FA=FA1
2065      P:02F0 200036  [2 -     1544]            NEG     A                                 ; else PKS1=0, set FA=-FA1
2066      P:02F1 4FA560  [2 -     1546]  FINDSUM_R ADD     X1,A                  Y:RSHFT+5,Y1 ;Find UGA2B=UGA2A+FA,
2067                                                                                         ; get shift constant
2068      P:02F2 21C500  [2 -     1548]            MOVE              A,X1
2069      P:02F3 4DDFF0  [2 -     1550]            MPY     X1,Y1,A               Y:(R7)+,X1  ;Find UGA2B>>7, get mask K22
2070      P:02F4 5F9B66  [2 -     1552]            AND     X1,A                  Y:SIGPK_R,B ;Truncate UGA2, get SIGPK
2071      P:02F5 4EE60B  [2 -     1554]            TST     B                     Y:(R6),Y0   ;Check SIGPK, get A2
2072      P:02F6 02B040  [2 -     1556]            TMI     X0,A                              ;If SIGPK=1, set UGA2=0
2073      P:02F7 4CA700  [2 -     1558]            MOVE                          Y:RSHFT+7,X0 ;Get shift constant
2074      P:02F8 2000D8  [2 -     1560]            MPY     Y0,X0,B                           ;Find A2>>7
2075      P:02F9 20006E  [2 -     1562]            AND     X1,B                              ;Truncate to find A2>>7
2076      P:02FA 24D03E  [2 -     1564]            NEG     B         #<$D0,X0                ;Find ULA2=-(A2>>7), get A2LL
2077      P:02FB 253010  [2 -     1566]            ADD     B,A       #<$30,X1                ;Find UA2=UGA2+ULA2, get A2UL
2078      P:02FC 4FDF50  [2 -     1568]            ADD     Y0,A                  Y:(R7)+,Y1  ;Find A2T=A2+UA2, get -gain (K23)
2079   
2080                                     ;**************************************************************************
2081                                     ;       LIMC
2082                                     ;
2083                                     ; Limit the A2 coefficient of the second order predictor.
2084                                     ;
2085                                     ;   |A2(k)| <= '0.75' 
2086                                     ;
2087                                     ; Inputs:
2088                                     ;   A2T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2089                                     ;
2090                                     ; Outputs:
2091                                     ;   A2P = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2092                                     ;
2093                                     ;**************************************************************************
2094   
2095      P:02FD 4EDF45  [2 -     1570]            CMP     X0,A                  Y:(R7)+,Y0  ;Check A2P, get +gain (K24)
2096      P:02FE 029040  [2 -     1572]            TLT     X0,A                              ;If A2P<-0.75, set A2P=-0.75






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 39



2097      P:02FF 578C65  [2 -     1574]            CMP     X1,A      X:PKS1,B                ;Check A2P again, get PKS1=PK0**PK1
2098      P:0300 027060  [2 -     1576]            TGT     X1,A                              ;If A2P>0.75, set A2P=0.75
2099      P:0301 5E1C00  [2 -     1578]            MOVE                          A,Y:A2P_R   ;Save A2P
2100      P:0302 5E5600  [2 -     1580]            MOVE                          A,Y:(R6)-   ;Save A2P to A2
2101   
2102                                     ;**************************************************************************
2103                                     ;       UPA1
2104                                     ;
2105                                     ; Update the A1 coefficient of the second order predictor.
2106                                     ;
2107                                     ; A1(k) = [1-(2**-8)] * A1(k-1)
2108                                     ;           + 3 * (2**-8) * sgn[P(k)] * sgn[P(k-1)]
2109                                     ;
2110                                     ; Inputs:
2111                                     ;   A1 = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2112                                     ;   SIGPK = Y:(R0) = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2113                                     ;   PK0 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
2114                                     ;   PK1 = sXXX XXXX | XXXX XXXX | 0000 0000  (1TC)
2115                                     ;     (Note: PKS1 has been previously calculated)
2116                                     ;
2117                                     ; Outputs:
2118                                     ;   A1T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2119                                     ;
2120                                     ;**************************************************************************
2121   
2122      P:0303 5F9B0B  [2 -     1582]            TST     B                     Y:SIGPK_R,B ;Check PKS1, get SIGPK
2123      P:0304 023050  [2 -     1584]            TPL     Y0,A                              ;If PKS=0, set UGA1=+gain
2124      P:0305 02B070  [2 -     1586]            TMI     Y1,A                              ;If PKS=1, set UGA1=-gain
2125      P:0306 24000B  [2 -     1588]            TST     B         #0,X0                   ;Check SIGPK
2126      P:0307 02B040  [2 -     1590]            TMI     X0,A                              ;If SIGPK=1, set UGA1=0
2127      P:0308 4DE600  [2 -     1592]            MOVE                          Y:(R6),X1   ;Get A1
2128      P:0309 4EA800  [2 -     1594]            MOVE                          Y:RSHFT+8,Y0 ;Get shift constant
2129      P:030A 4CDFE8  [2 -     1596]            MPY     Y0,X1,B               Y:(R7)+,X0  ;Find A1>>8, get mask K25
2130      P:030B 20004E  [2 -     1598]            AND     X0,B                              ;Truncate (A1>>8)
2131      P:030C 20003E  [2 -     1600]            NEG     B                                 ;Find ULA1=-(A1>>8)
2132      P:030D 2F3C10  [2 -     1602]            ADD     B,A       #<$3C,B                 ;Find UA1=UGA1+ULA1,
2133                                                                                         ; get OME='1-(2**-4)'
2134      P:030E 4C9C60  [2 -     1604]            ADD     X1,A                  Y:A2P_R,X0  ;Find A1T=A1+UA1, get A2P
2135   
2136                                     ;**************************************************************************
2137                                     ;       LIMD
2138                                     ;
2139                                     ; Limit the A1 coefficient of the second order predictor.
2140                                     ;
2141                                     ;   |A1(k)| <= [1-(2**-4)] - A2(k)
2142                                     ;
2143                                     ; Inputs:
2144                                     ;   A1T = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2145                                     ;   A2P = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2146                                     ;
2147                                     ; Outputs:
2148                                     ;   A1P = Y:(R6) = si.ff ffff | ffff ffff | 0000 0000 (16TC)
2149                                     ;
2150                                     ;**************************************************************************
2151   
2152      P:030F 20004C  [2 -     1606]            SUB     X0,B                              ;Find A1UL=OME-A2P






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 40



2153      P:0310 21E405  [2 -     1608]            CMP     B,A       B,X0                    ;Check A1T
2154      P:0311 027040  [2 -     1610]            TGT     X0,A                              ;If A1T>A1UL, set A1P=A1UL
2155      P:0312 205A3E  [2 -     1612]            NEG     B         (R2)+                   ;Find A1LL=-A1UL=A2P-OME
2156      P:0313 21E405  [2 -     1614]            CMP     B,A       B,X0                    ;Check A1T again
2157      P:0314 029040  [2 -     1616]            TLT     X0,A                              ;If A1T<A1LL, set A1P=A1LL
2158      P:0315 5C5E00  [2 -     1618]            MOVE                          A1,Y:(R6)+  ;Store A1P to A1
2159      P:0316 205E00  [2 -     1620]            MOVE              (R6)+                   ;Adjust coef pointer
2160   
2161                                     ;**************************************************************************
2162                                     ;       FLOATA
2163                                     ;
2164                                     ; Converts the quantized difference signal from 15-bit
2165                                     ;   signed magnitude to floating pt. format (11FL - sign,
2166                                     ;   exp, and mant stored separately)
2167                                     ;
2168                                     ; Inputs:
2169                                     ;   DQ = siii iiii | iiii iii.0 | 0000 0000 (15SM)
2170                                     ;
2171                                     ; Outputs:
2172                                     ;   DQ0 = (11FL)
2173                                     ;    DQ0EXP = X:(R2) = 0000 0000 | 0000 0000 | 0000 eeee
2174                                     ;    DQ0MANT = X:(R2+1) = 01mm mmm0 | 0000 0000 | 0000 0000
2175                                     ;    DQ0S = X:(R2+2) = sXXX XXXX | XXXX XXXX | 0000 0000
2176                                     ;
2177                                     ;**************************************************************************
2178   
2179      P:0317 468600  [2 -     1622]            MOVE              X:DQ_R,Y0               ;Get DQS
2180      P:0318 5E9F00  [2 -     1624]            MOVE                          Y:DQMAG,A   ;Get MAG=DQMAG
2181      P:0319 300E03  [2 -     1626]            TST     A         #$000E,R0               ;Check MAG, get exponent bias (14)
2182      P:031A 0E231E  [4 -     1630]            JNE     <NORMDQ_R                         ;Test MAG
2183      P:031B 2E4000  [2 -     1632]            MOVE              #<$40,A                 ;If MAG=0 set MANT=100000,
2184      P:031C 300000  [2 -     1634]            MOVE              #0,R0                   ; and EXP=0
2185      P:031D 0C032B  [4 -     1638]            JMP     <TRUNCDQ_R
2186      P:031E 01D815  [2 -     1640]  NORMDQ_R  NORM    R0,A                              ;If MAG!=0 do NORM iteration 13
2187      P:031F 01D815  [2 -     1642]            NORM    R0,A                              ; times to find MSB of MAG
2188      P:0320 01D815  [2 -     1644]            NORM    R0,A
2189      P:0321 01D815  [2 -     1646]            NORM    R0,A
2190      P:0322 01D815  [2 -     1648]            NORM    R0,A
2191      P:0323 01D815  [2 -     1650]            NORM    R0,A
2192      P:0324 01D815  [2 -     1652]            NORM    R0,A
2193      P:0325 01D815  [2 -     1654]            NORM    R0,A
2194      P:0326 01D815  [2 -     1656]            NORM    R0,A
2195      P:0327 01D815  [2 -     1658]            NORM    R0,A
2196      P:0328 01D815  [2 -     1660]            NORM    R0,A
2197      P:0329 01D815  [2 -     1662]            NORM    R0,A
2198      P:032A 01D815  [2 -     1664]            NORM    R0,A
2199                                     ;   A1 = 01?? ???? | ???? ???0 | 0000 0000 = normalized MAG (A2=A0=0)
2200                                     ;   R0 = 0000 0000 | 0000 eeee = exponent of normalized MAG
2201   
2202      P:032B 247E00  [2 -     1666]  TRUNCDQ_R MOVE              #<$7E,X0                ;Get mask
2203      P:032C 605A46  [2 -     1668]            AND     X0,A      R0,X:(R2)+              ;Truncate MANT to 6 bits,
2204                                                                                         ; save EXP to DQ1EXP
2205                                     ;   A1 = 01mm mmm0 | 0000 0000 | 0000 0000  (A2=A0=0)
2206      P:032D 545A00  [2 -     1670]            MOVE              A1,X:(R2)+              ;Save MANT to DQ1MANT
2207      P:032E 465A00  [2 -     1672]            MOVE              Y0,X:(R2)+              ;Save DQ to DQ1S
2208   






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 41



2209                                     ;**************************************************************************
2210                                     ;       FLOATB
2211                                     ;
2212                                     ; Converts the reconstructed signal from 16-bit two's 
2213                                     ;   complement to floating pt. format (11FL - sign,
2214                                     ;   exp, and mant stored separately)
2215                                     ;
2216                                     ; Inputs:
2217                                     ;   SR = siii iiii | iiii iiii. | 0000 0000  (16TC)
2218                                     ;
2219                                     ; Outputs:
2220                                     ;   SR0 = (11FL)
2221                                     ;    SR0EXP = X:(R2) = 0000 0000 | 0000 0000 | 0000 eeee
2222                                     ;    SR0MANT = X:(R2+1) = 01mm mmm0 | 0000 0000 | 0000 0000
2223                                     ;    SR0S = X:(R2+2) = sXXX XXXX | XXXX XXXX | 0000 0000
2224                                     ;
2225                                     ;**************************************************************************
2226   
2227      P:032F 3A0F00  [2 -     1674]            MOVE              #15,N2
2228      P:0330 5F9100  [2 -     1676]            MOVE                          Y:SR_R,B    ;Get SR
2229      P:0331 204A00  [2 -     1678]            MOVE              (R2)+N2                 ;Adjust data pointer
2230      P:0332 21E62E  [2 -     1680]            ABS     B         B,Y0                    ;Find MAG=|SR|, save SRS
2231      P:0333 300F0B  [2 -     1682]            TST     B         #$000F,R0               ;Load exponent bias
2232      P:0334 0E2338  [4 -     1686]            JNE     <NORMSR_R                         ;Test MAG
2233      P:0335 2F4000  [2 -     1688]            MOVE              #<$40,B                 ;If MAG=0 set MANT=100000,
2234      P:0336 300000  [2 -     1690]            MOVE              #0,R0                   ; and EXP=0
2235      P:0337 0C0346  [4 -     1694]            JMP     <TRUNCSR_R
2236      P:0338 01D81D  [2 -     1696]  NORMSR_R  NORM    R0,B                              ;If MAG!=0 do NORM iteration 14
2237      P:0339 01D81D  [2 -     1698]            NORM    R0,B                              ; times to find MSB of MAG
2238      P:033A 01D81D  [2 -     1700]            NORM    R0,B
2239      P:033B 01D81D  [2 -     1702]            NORM    R0,B
2240      P:033C 01D81D  [2 -     1704]            NORM    R0,B
2241      P:033D 01D81D  [2 -     1706]            NORM    R0,B
2242      P:033E 01D81D  [2 -     1708]            NORM    R0,B
2243      P:033F 01D81D  [2 -     1710]            NORM    R0,B
2244      P:0340 01D81D  [2 -     1712]            NORM    R0,B
2245      P:0341 01D81D  [2 -     1714]            NORM    R0,B
2246      P:0342 01D81D  [2 -     1716]            NORM    R0,B
2247      P:0343 01D81D  [2 -     1718]            NORM    R0,B
2248      P:0344 01D81D  [2 -     1720]            NORM    R0,B
2249      P:0345 01D81D  [2 -     1722]            NORM    R0,B
2250                                     ;   A1 = 01?? ???? | ???? ???0 | 0000 0000 = normalized MAG (A2=A0=0)
2251                                     ;   R0 = 0000 0000 | 0000 eeee = exponent of normalized MAG
2252   
2253      P:0346 605A4E  [2 -     1724]  TRUNCSR_R AND     X0,B      R0,X:(R2)+              ;Truncate MANT to 6 bits,
2254                                                                                         ; save EXP to SR1EXP
2255                                     ;   A1 = 01mm mmm0 | 0000 0000 | 0000 0000  (A2=A0=0)
2256      P:0347 555A00  [2 -     1726]            MOVE              B1,X:(R2)+              ;Save MANT to SR1MANT
2257      P:0348 465A00  [2 -     1728]            MOVE              Y0,X:(R2)+              ;Save SR to SR1S
2258      P:0349 3A0300  [2 -     1730]            MOVE              #3,N2
2259      P:034A 5F9C00  [2 -     1732]            MOVE                          Y:A2P_R,B   ;Get A2P
2260      P:034B 204A00  [2 -     1734]            MOVE              (R2)+N2                 ;Adjust data pointer
2261   
2262                                     ;**************************************************************************
2263                                     ;       TONE
2264                                     ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 42



2265                                     ; Partial band signal detection
2266                                     ;
2267                                     ; TD(k) = 1 if A2(k) < -0.71875
2268                                     ;         0 otherwise
2269                                     ;
2270                                     ; Inputs:
2271                                     ;   A2P = si.ff ffff | ffff ffff | 0000 0000  (16TC)
2272                                     ;
2273                                     ; Output:
2274                                     ;   TDP = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2275                                     ;
2276                                     ;**************************************************************************
2277   
2278      P:034C 24D213  [2 -     1736]            CLR     A         #<$D2,X0                ;Get '-.71875', set TDP=0
2279      P:034D 25804D  [2 -     1738]            CMP     X0,B      #<$80,X1                ;Check A2P, get '1'
2280      P:034E 029060  [2 -     1740]            TLT     X1,A                              ;If A2P<-.71875 set TDP=1, else TDP=0
2281      P:034F 5C1700  [2 -     1742]            MOVE                          A1,Y:TDP_R  ;Save TDP
2282      P:0350 5C1800  [2 -     1744]            MOVE                          A1,Y:TD_R   ;Save TDP to TD
2283   
2284                                     ;**************************************************************************
2285                                     ;       TRIGB
2286                                     ;
2287                                     ; Predictor trigger block
2288                                     ;
2289                                     ; If TR(k) = 1, An(k)=Bn(k)=TD(k)=0
2290                                     ;
2291                                     ; Inputs:
2292                                     ;   TR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2293                                     ;   BnP = si.ff ffff | ffff ffff | 0000 0000  (16TC)
2294                                     ;   AnP = si.ff ffff | ffff ffff | 0000 0000  (16TC)
2295                                     ;   TDP = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2296                                     ;
2297                                     ; Output:
2298                                     ;   BnR = si.ff ffff | ffff ffff | 0000 0000  (16TC)
2299                                     ;   AnR = si.ff ffff | ffff ffff | 0000 0000  (16TC)
2300                                     ;   TDR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2301                                     ;
2302                                     ;**************************************************************************
2303   
2304      P:0351 5F9D00  [2 -     1746]            MOVE                          Y:TR_R,B    ;Get TR
2305      P:0352 2E000B  [2 -     1748]            TST     B         #0,A                    ;Test TR
2306      P:0353 0EA35D  [4 -     1752]            JEQ     <FUNCTF_R                         ;If TR=0 continue
2307      P:0354 5E1800  [2 -     1754]            MOVE                          A,Y:TD_R    ;If TR=1, set TDR=0,
2308      P:0355 5E5E00  [2 -     1756]            MOVE                          A,Y:(R6)+   ; and B1-B6,A1,A2=0
2309      P:0356 5E5E00  [2 -     1758]            MOVE                          A,Y:(R6)+
2310      P:0357 5E5E00  [2 -     1760]            MOVE                          A,Y:(R6)+
2311      P:0358 5E5E00  [2 -     1762]            MOVE                          A,Y:(R6)+
2312      P:0359 5E5E00  [2 -     1764]            MOVE                          A,Y:(R6)+
2313      P:035A 5E5E00  [2 -     1766]            MOVE                          A,Y:(R6)+
2314      P:035B 5E5E00  [2 -     1768]            MOVE                          A,Y:(R6)+
2315      P:035C 5E5E00  [2 -     1770]            MOVE                          A,Y:(R6)+
2316   
2317                                     ;**************************************************************************
2318                                     ;       FUNCTF
2319                                     ;
2320                                     ; Maps quantizer output I into F(I) function






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 43



2321                                     ;
2322                                     ;  |I(k)|  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
2323                                     ; ---------+---+---+---+---+---+---+---+---+
2324                                     ;  F[I(k)] | 7 | 3 | 1 | 1 | 1 | 0 | 0 | 0 |
2325                                     ;
2326                                     ; Inputs:
2327                                     ;   I = siii 0000 | 0000 0000 | 0000 0000
2328                                     ;
2329                                     ; Output:
2330                                     ;   FI = 0iii. 0000 | 0000 0000 | 0000 0000  (3SM)
2331                                     ;   IMAG
2332                                     ;
2333                                     ;**************************************************************************
2334   
2335      P:035D 242000  [2 -     1772]  FUNCTF_R  MOVE              #<$20,X0
2336      P:035E 568B00  [2 -     1774]            MOVE              X:IMAG,A                ;Get |I|
2337      P:035F 245045  [2 -     1776]            CMP     X0,A      #<$50,X0                ;Test for |I|<=2
2338      P:0360 0EF36B  [4 -     1780]            JLE     <RANGE0_R
2339      P:0361 246045  [2 -     1782]            CMP     X0,A      #<$60,X0                ;Test for 3<=|I|<=5
2340      P:0362 0EF369  [4 -     1786]            JLE     <RANGE1_R
2341      P:0363 200045  [2 -     1788]            CMP     X0,A                              ;Test for |I|=6
2342      P:0364 0EA367  [4 -     1792]            JEQ     <RANGE3_R
2343      P:0365 2E7000  [2 -     1794]            MOVE              #<$70,A                 ;|I|=7, set F[I]=7
2344      P:0366 0C036C  [4 -     1798]            JMP     <FILTA_R
2345      P:0367 2E3000  [2 -     1800]  RANGE3_R  MOVE              #<$30,A                 ;|I|=6, set F[I]=3
2346      P:0368 0C036C  [4 -     1804]            JMP     <FILTA_R
2347      P:0369 2E1000  [2 -     1806]  RANGE1_R  MOVE              #<$10,A                 ;|I|=3,4,or 5, set F[I]=1
2348      P:036A 0C036C  [4 -     1810]            JMP     <FILTA_R
2349      P:036B 200013  [2 -     1812]  RANGE0_R  CLR     A                                 ;|I|=0,1,or 2, set F[I]=0
2350   
2351                                     ;**************************************************************************
2352                                     ;       FILTA
2353                                     ;
2354                                     ; Update short term average of F(I)
2355                                     ;
2356                                     ; DMS(k) = (1 - 2**(-5)) * DMS(k-1) + 2**(-5) * F[I(k)]
2357                                     ;
2358                                     ; Inputs:
2359                                     ;   FI = 0iii. 0000 | 0000 0000 | 0000 0000  (3SM)
2360                                     ;   DMS = 0iii. ffff | ffff f000 | 0000 0000  (12SM)
2361                                     ;
2362                                     ; Output:
2363                                     ;   DMSP = 0iii. ffff | ffff f000 | 0000 0000  (12SM)
2364                                     ;
2365                                     ;**************************************************************************
2366   
2367      P:036C 4E9500  [2 -     1814]  FILTA_R   MOVE                          Y:DMS_R,Y0  ;Get DMS
2368      P:036D 21CF54  [2 -     1816]            SUB     Y0,A      A,B                     ;Find DIF=FI-DMS, save FI
2369      P:036E 11DF00  [2 -     1818]            MOVE              A,X0        Y:(R7)+,Y1  ;Save DIF, get mask K26
2370      P:036F 4CDFC0  [2 -     1820]            MPY     X0,Y1,A               Y:(R7)+,X0  ;Find DIFSX=DIF>>5, get mask K27
2371      P:0370 4F9646  [2 -     1822]            AND     X0,A                  Y:DML_R,Y1  ;Truncate DIFSX, get DML
2372      P:0371 4DA750  [2 -     1824]            ADD     Y0,A                  Y:RSHFT+7,X1 ;Find DMSP=DIFSX+DMS
2373   
2374                                     ;**************************************************************************
2375                                     ;       FILTB
2376                                     ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 44



2377                                     ; Update long term average of F(I)
2378                                     ;
2379                                     ; DML(k) = (1 - 2**(-7)) * DML(k-1) + 2**(-7) * F[I(k)]
2380                                     ;
2381                                     ; Inputs:
2382                                     ;   FI = 0iii. 0000 | 0000 0000 | 0000 0000  (3SM)
2383                                     ;   DML = 0iii. ffff | ffff fff0 | 0000 0000  (14SM)
2384                                     ;
2385                                     ; Output:
2386                                     ;   DMLP = 0iii. ffff | ffff fff0 | 0000 0000  (14SM)
2387                                     ;
2388                                     ;**************************************************************************
2389   
2390      P:0372 5C157C  [2 -     1826]            SUB     Y1,B                  A1,Y:DMS_R  ;Find DIF=FI-DML
2391      P:0373 21A400  [2 -     1828]            MOVE              B1,X0
2392      P:0374 4CDFA8  [2 -     1830]            MPY     X0,X1,B               Y:(R7)+,X0  ;Find DFISX=DIF>>7, get mask K28
2393      P:0375 20004E  [2 -     1832]            AND     X0,B                              ;Truncate DIFSX
2394      P:0376 4DA378  [2 -     1834]            ADD     Y1,B                  Y:RSHFT+3,X1 ;Find DMLP=DIFSX+DML
2395   
2396                                     ;**************************************************************************
2397                                     ;       SUBTC
2398                                     ;
2399                                     ; Compute magnitude of the difference of short and long
2400                                     ;  term functions of quantizer output sequence and then
2401                                     ;  perform threshold comparison for quantizing speed control
2402                                     ;  parameter.
2403                                     ;
2404                                     ; AX = 1  if Y>=3, TDP=1, & |DMSP-DMLP|>(2**-3)*DMLP
2405                                     ;    = 0  otherwise
2406                                     ;
2407                                     ; Input:
2408                                     ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
2409                                     ;   DMSP = 0iii. ffff | ffff f000 | 0000 0000  (12SM)
2410                                     ;   DMLP = 0iii. ffff | ffff fff0 | 0000 0000  (14SM)
2411                                     ;   TDP = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2412                                     ;
2413                                     ; Output:
2414                                     ;   AX = 0i0.0 0000 | 0000 0000 | 0000 0000  (1SM)
2415                                     ;
2416                                     ;**************************************************************************
2417   
2418      P:0377 5D1614  [2 -     1836]            SUB     B,A                   B1,Y:DML_R  ;Find DIF=DMSP-DMLP, save DML
2419      P:0378 21A626  [2 -     1838]            ABS     A         B1,Y0                   ;Find DIFM=|DIF|
2420      P:0379 2618E8  [2 -     1840]            MPY     X1,Y0,B   #<$18,Y0                ;Find DTHR=DMLP>>3, get '3'
2421      P:037A 24404E  [2 -     1842]            AND     X0,B      #<$40,X0                ;Truncate DTHR, get '1'
2422      P:037B 2F0005  [2 -     1844]            CMP     B,A       #0,B                    ;Compare DIFM & DTHR, set AX=0
2423      P:037C 021048  [2 -     1846]            TGE     X0,B                              ;If DIFM>=DTHR set AX=1
2424      P:037D 5E9700  [2 -     1848]            MOVE                          Y:TDP_R,A   ;Get TDP
2425      P:037E 568703  [2 -     1850]            TST     A         X:Y_R,A                 ;Check TDP, get Y
2426      P:037F 022048  [2 -     1852]            TNE     X0,B                              ;If TDP!=0 set AX=1
2427      P:0380 458855  [2 -     1854]            CMP     Y0,A      X:AP_R,X1               ;Check for Y<"3", get AP
2428      P:0381 029048  [2 -     1856]            TLT     X0,B                              ;If Y<"3" set AX=1
2429   
2430                                     ;**************************************************************************
2431                                     ;       FILTC
2432                                     ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 45



2433                                     ; Low pass filter of speed control parameter
2434                                     ;
2435                                     ; AP(k) = (1-2**(-4)) * AP(k-1) + AX
2436                                     ;
2437                                     ; Inputs:
2438                                     ;   AX = 0i0.0 0000 | 0000 0000 | 0000 0000  (1SM)
2439                                     ;   AP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
2440                                     ;
2441                                     ; Outputs:
2442                                     ;   APP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
2443                                     ;
2444                                     ;**************************************************************************
2445   
2446      P:0382 4EA46C  [2 -     1858]            SUB     X1,B                  Y:RSHFT+4,Y0 ;Find DIF=AX-AP
2447      P:0383 21A400  [2 -     1860]            MOVE              B1,X0
2448      P:0384 4CDFD0  [2 -     1862]            MPY     X0,Y0,A               Y:(R7)+,X0  ;Find DIFSX=DIF>>4, get K29
2449      P:0385 5F9D46  [2 -     1864]            AND     X0,A                  Y:TR_R,B    ;Truncate DIFSX, get TR
2450      P:0386 242060  [2 -     1866]            ADD     X1,A      #<$20,X0                ;Find APP=DIFSX+AP, get '1'
2451   
2452                                     ;**************************************************************************
2453                                     ;       TRIGA
2454                                     ;
2455                                     ; Speed control trigger block
2456                                     ;
2457                                     ; AP(k) = AP(k) if TR(k)=0
2458                                     ;       =  1    if TR(k)=1
2459                                     ;
2460                                     ; Inputs:
2461                                     ;   TR = i000 0000 | 0000 0000 | 0000 0000  (1TC)
2462                                     ;   APP = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
2463                                     ;
2464                                     ; Outputs:
2465                                     ;   APR = 0ii.f ffff | fff0 0000 | 0000 0000  (10SM)
2466                                     ;
2467                                     ;**************************************************************************
2468   
2469      P:0387 458B0B  [2 -     1868]            TST     B         X:IMAG,X1               ;Check TR, get IMAG
2470      P:0388 02B040  [2 -     1870]            TMI     X0,A                              ;If TR=1 set APR=1, else APR=APP
2471      P:0389 540800  [2 -     1872]            MOVE              A1,X:AP_R               ;Save APR to AP
2472   
2473                                     ;**************************************************************************
2474                                     ;       FUNCTW
2475                                     ;
2476                                     ; Map quantizer output into logarithmic version of scale
2477                                     ;  factor multiplier
2478                                     ;
2479                                     ;  |I(k)|  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
2480                                     ; ---------+-----+-----+-----+-----+-----+-----+-----+-----+
2481                                     ;   W(I)   |70.13|22.19|12.38| 7.00| 4.00| 2.56| 1.13|-0.75|
2482                                     ;
2483                                     ; Inputs:
2484                                     ;   I = siii. 0000 | 0000 0000 | 0000 0000  (ADPCM format)
2485                                     ;
2486                                     ; Outputs:
2487                                     ;   WI = siii iiii. | ffff 0000 | 0000 0000  (12TC)
2488                                     ;






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 46



2489                                     ;**************************************************************************
2490   
2491      P:038A 4CB400  [2 -     1874]            MOVE                          Y:RSHFT+20,X0 ;Get shift constant
2492      P:038B 3020A0  [2 -     1876]            MPY     X0,X1,A   #WIBASE,R0              ;Shift IM=IMAG for lookup,
2493                                                                                         ; load lookup table base
2494      P:038C 219800  [2 -     1878]            MOVE              A1,N0                   ;Load IM as offset
2495      P:038D 4DA300  [2 -     1880]            MOVE                          Y:RSHFT+3,X1 ;Get shift constant
2496      P:038E 468700  [2 -     1882]            MOVE              X:Y_R,Y0                ;Get Y
2497      P:038F 56E8E8  [4 -     1886]            MPY     Y0,X1,B   X:(R0+N0),A             ;Shift Y>>3,
2498                                                                                         ; get WI from lookup table
2499   
2500                                     ;**************************************************************************
2501                                     ;       FILTD
2502                                     ;
2503                                     ; Update of fast quantizer scale factor
2504                                     ;
2505                                     ; YU(k) = (1 - 2**(-5)) * Y(k) + 2**(-5) * W[I(k)]
2506                                     ;
2507                                     ; Inputs:
2508                                     ;   WI =  siii iiii. | ffff 0000 | 0000 0000  (12TC)
2509                                     ;   Y = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
2510                                     ;
2511                                     ; Outputs:
2512                                     ;   YUT = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
2513                                     ;
2514                                     ;**************************************************************************
2515   
2516      P:0390 200014  [2 -     1888]            SUB     B,A                               ;Find DIF=WI-Y
2517      P:0391 200022  [2 -     1890]            ASR     A                                 ;Find DIFSX=DIF>>5 (actually DIF>>2)
2518      P:0392 4CDF22  [2 -     1892]            ASR     A                     Y:(R7)+,X0  ;Get mask K30
2519      P:0393 200046  [2 -     1894]            AND     X0,A                              ;Truncate DIFSX
2520      P:0394 245050  [2 -     1896]            ADD     Y0,A      #<$50,X0                ;Find YUT=DIFSX+Y,
2521                                                                                         ; get upper limit '10'
2522   
2523                                     ;**************************************************************************
2524                                     ;       LIMB
2525                                     ;
2526                                     ; Limit quantizer scale factor
2527                                     ;
2528                                     ; 1.06 <= YU(k) <= 10.00
2529                                     ;
2530                                     ; Inputs:
2531                                     ;   YUT = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
2532                                     ;
2533                                     ; Outputs:
2534                                     ;   YUP = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
2535                                     ;
2536                                     ;**************************************************************************
2537   
2538      P:0395 4DDF45  [2 -     1898]            CMP     X0,A                  Y:(R7)+,X1  ;Check for YU>10,
2539                                                                                         ; get lower limit '1.06' (K31)
2540      P:0396 027040  [2 -     1900]            TGT     X0,A                              ;If YU>10 set YU=10
2541      P:0397 4F9A65  [2 -     1902]            CMP     X1,A                  Y:YL_R,Y1   ;Check for YU<1.06, get YL
2542      P:0398 029060  [2 -     1904]            TLT     X1,A                              ;If YU<1.06 set YU=1.06
2543   
2544                                     ;**************************************************************************






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 47



2545                                     ;       FILTE
2546                                     ;
2547                                     ; Update of slow quantizer scale factor
2548                                     ;
2549                                     ; YL(k) = (1 - 2**(-6)) * YL(k-1) + 2**(-6) * YU(k)
2550                                     ;
2551                                     ; Inputs:
2552                                     ;   YUP = 0iii i.fff | ffff ff00 | 0000 0000  (13SM)
2553                                     ;   YL = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
2554                                     ;
2555                                     ; Outputs:
2556                                     ;   YLP = 0iii i.fff | ffff ffff | ffff 0000  (19SM)
2557                                     ;
2558                                     ;**************************************************************************
2559   
2560      P:0399 5C1979  [2 -     1906]            TFR     Y1,B                  A1,Y:YU_R   ;Move YL, save YUP
2561      P:039A 4EDF3E  [2 -     1908]            NEG     B                     Y:(R7)+,Y0  ;Find -YL, save YL, get mask K32
2562      P:039B 373B5E  [2 -     1910]            AND     Y0,B      #CONST4,R7              ;Truncate -YL (-YL>>6),
2563                                                                                         ; adjust constant pointer
2564      P:039C 4EA610  [2 -     1912]            ADD     B,A                   Y:RSHFT+6,Y0 ;Find DIF=YUP+(-YL>>6)
2565      P:039D 218500  [2 -     1914]            MOVE              A1,X1
2566      P:039E 46F4E0  [4 -     1918]            MPY     Y0,X1,A   #$002100,Y0             ;Find DIFSX>>6, get bias
                 002100
2567      P:03A0 5F9E70  [2 -     1920]            ADD     Y1,A                  Y:LAW,B     ;Find YLP=DIFSX+YL
2568      P:03A1 5C1A00  [2 -     1922]            MOVE                          A1,Y:YL_R   ;Save YL
2569   
2570                                     ;**************************************************************************
2571                                     ;       COMPRESS ELIMINATED
2572                                     ;
2573                                     ;**************************************************************************
2574   
2575                                     ;**************************************************************************
2576                                     ;       EXPAND ELIMINATED
2577                                     ;**************************************************************************
2578   
2579                                     ;**************************************************************************
2580                                     ;       SUBTA ELIMINATED
2581                                     ;**************************************************************************
2582   
2583   
2584                                     ;**************************************************************************
2585                                     ;       LOG ELIMINATED
2586                                     ;**************************************************************************
2587   
2588                                     ;**************************************************************************
2589                                     ;       SUBTB ELIMINATED
2590                                     ;
2591                                     ;**************************************************************************
2592   
2593   
2594                                     ;**************************************************************************
2595                                     ;       SYNC ELIMINATED
2596                                     ;
2597                                     ;**************************************************************************
2598   
2599   






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 48



2600                                     ;**************************************************************************
2601                                     ;       INIT ELIMINATED !
2602                                     ;
2603                                     ;**************************************************************************
2604   
2605   
2606                                     ;QUANTAB
2607 d    P:03A2 F84000                  VARINIT   DC      $F84000                           ;-0.98
2608 d    P:03A3 050000                            DC      $050000                           ;0.62
2609 d    P:03A4 0B2000                            DC      $0B2000                           ;1.38
2610 d    P:03A5 0F6000                            DC      $0F6000                           ;1.91
2611 d    P:03A6 12C000                            DC      $12C000                           ;2.34
2612 d    P:03A7 15D000                            DC      $15D000                           ;2.72
2613 d    P:03A8 190000                            DC      $190000                           ;3.12
2614 d    P:03A9 7FFFFF                            DC      $7FFFFF                           ;15.99
2615                                     ;IQUANTAB
2616 d    P:03AA 800000                            DC      $800000                           ;-16    |I|=0
2617 d    P:03AB 004000                            DC      $004000                           ;0.031  |I|=1
2618 d    P:03AC 087000                            DC      $087000                           ;1.05   |I|=2
2619 d    P:03AD 0D5000                            DC      $0D5000                           ;1.66   |I|=3
2620 d    P:03AE 111000                            DC      $111000                           ;2.13   |I|=4
2621 d    P:03AF 143000                            DC      $143000                           ;2.52   |I|=5
2622 d    P:03B0 175000                            DC      $175000                           ;2.91   |I|=6
2623 d    P:03B1 1A9000                            DC      $1A9000                           ;3.32   |I|=7
2624                                     ;WIBASE
2625 d    P:03B2 FF4000                            DC      $FF4000                           ;-0.75  |I|=0
2626 d    P:03B3 012000                            DC      $012000                           ;1.13   |I|=1
2627 d    P:03B4 029000                            DC      $029000                           ;2.56   |I|=2
2628 d    P:03B5 040000                            DC      $040000                           ;4.00   |I|=3
2629 d    P:03B6 070000                            DC      $070000                           ;7.00   |I|=4
2630 d    P:03B7 0C6000                            DC      $0C6000                           ;12.38  |I|=5
2631 d    P:03B8 163000                            DC      $163000                           ;22.19  |I|=6
2632 d    P:03B9 462000                            DC      $462000                           ;70.13  |I|=7
2633                                     ;TAB
2634 d    P:03BA 1E0000                            DC      $1E0000
2635 d    P:03BB 3E0000                            DC      $3E0000
2636 d    P:03BC 5E0000                            DC      $5E0000
2637 d    P:03BD 7E0000                            DC      $7E0000
2638 d    P:03BE 9E0000                            DC      $9E0000
2639 d    P:03BF BE0000                            DC      $BE0000
2640 d    P:03C0 DE0000                            DC      $DE0000
2641 d    P:03C1 FE0000                            DC      $FE0000
2642                                     ;CONST - constants used in FMULT
2643 d    P:03C2 FFFC00                            DC      $FFFC00                           ;KF1 = trunc mask
2644 d    P:03C3 7FFC00                            DC      $7FFC00                           ;KF2 = trunc mask
2645 d    P:03C4 018000                            DC      $018000                           ;KF3 = '48'
2646 d    P:03C5 7F8000                            DC      $7F8000                           ;KF4 = trunc mask
2647 d    P:03C6 00001A                            DC      $00001A                           ;KF5 = '26'
2648 d    P:03C7 7FFF00                            DC      $7FFF00                           ;KF6 = trunc mask
2649   
2650                                     ;RSHFT
2651 d    P:03C8 800000                            DC      $800000
2652 d    P:03C9 400000                            DC      $400000                           ;>>1    <<23
2653 d    P:03CA 200000                            DC      $200000                           ;>>2    <<22
2654 d    P:03CB 100000                            DC      $100000                           ;>>3    <<21
2655 d    P:03CC 080000                            DC      $080000                           ;>>4    <<20






Motorola DSP56000 Macro Cross Assembler  Version 3.04  93-11-12  14:38:31  adpcm.asm  Page 49



2656 d    P:03CD 040000                            DC      $040000                           ;>>5    <<19
2657 d    P:03CE 020000                            DC      $020000                           ;>>6    <<18
2658 d    P:03CF 010000                            DC      $010000                           ;>>7    <<17
2659 d    P:03D0 008000                            DC      $008000                           ;>>8    <<16
2660 d    P:03D1 004000                            DC      $004000                           ;>>9    <<15
2661 d    P:03D2 002000                            DC      $002000                           ;>>10   <<14
2662 d    P:03D3 001000                            DC      $001000                           ;>>11   <<13
2663 d    P:03D4 000800                            DC      $000800                           ;>>12   <<12
2664 d    P:03D5 000400                            DC      $000400                           ;>>13   <<11
2665 d    P:03D6 000200                            DC      $000200                           ;>>14   <<10
2666 d    P:03D7 000100                            DC      $000100                           ;>>15   <<9
2667 d    P:03D8 000080                            DC      $000080                           ;>>16   <<8
2668 d    P:03D9 000040                            DC      $000040                           ;>>17   <<7
2669 d    P:03DA 000020                            DC      $000020                           ;>>18   <<6
2670 d    P:03DB 000010                            DC      $000010                           ;>>19   <<5
2671 d    P:03DC 000008                            DC      $000008                           ;>>20   <<4
2672 d    P:03DD 000004                            DC      $000004                           ;>>21   <<3
2673 d    P:03DE 000002                            DC      $000002                           ;>>22   <<2
2674 d    P:03DF 000001                            DC      $000001                           ;>>23   <<1
2675                                     ;CONST1
2676 d    P:03E0 FFFE00                            DC      $FFFE00                           ;K1 = trunc mask (ACCUM)
2677 d    P:03E1 7FFC00                            DC      $7FFC00                           ;K2 = trunc mask (MIX)
2678 d    P:03E2 7FFE00                            DC      $7FFE00                           ;K3 = trunc mask (MIX)
2679 d    P:03E3 000080                            DC      $000080                           ;K4 = shift const (EXPAND)
2680 d    P:03E4 00007F                            DC      $00007F                           ;K5 = sign mask (EXPAND)
2681 d    P:03E5 3F8000                            DC      $3F8000                           ;K6 = trunc mask (LOG)
2682 d    P:03E6 100000                            DC      $100000                           ;K7 = shift const (LOG)
2683 d    P:03E7 7FF000                            DC      $7FF000                           ;K8 = trunc mask (SUBTB & ADDA)
2684 d    P:03E8 07F000                            DC      $07F000                           ;K9 = sign mask (ANTILOG)
2685 d    P:03E9 00000A                            DC      $00000A                           ;K10 = '10' (ANTILOG)
2686 d    P:03EA 7FFE00                            DC      $7FFE00                           ;K11 = trunc mask (ANTILOG)
2687 d    P:03EB 07C000                            DC      $07C000                           ;K12 = trunc mask (TRANS)
2688 d    P:03EC 000010                            DC      $000010                           ;K13 = shift const (TRANS)
2689 d    P:03ED 000008                            DC      $000008                           ;K14 = '8' (TRANS)
2690 d    P:03EE 000005                            DC      $000005                           ;K15 = '5' (TRANS)
2691 d    P:03EF 7FFE00                            DC      $7FFE00                           ;K16 = trunc mask (TRANS)
2692 d    P:03F0 008000                            DC      $008000                           ;K17 = +gain (UPB)
2693 d    P:03F1 FF8000                            DC      $FF8000                           ;K18 = -gain (UPB)
2694 d    P:03F2 FFFF00                            DC      $FFFF00                           ;K19 = trunc mask (UPB)
2695 d    P:03F3 1FFF00                            DC      $1FFF00                           ;K20 = '+1.99' (UPA2)
2696 d    P:03F4 E00100                            DC      $E00100                           ;K21 = '-1.99' (UPA2)
2697 d    P:03F5 FFFF00                            DC      $FFFF00                           ;K22 = trunc mask (UPA2)
2698 d    P:03F6 FF4000                            DC      $FF4000                           ;K23 = -gain (UPA1)
2699 d    P:03F7 00C000                            DC      $00C000                           ;K24 = +gain (UPA1)
2700 d    P:03F8 FFFF00                            DC      $FFFF00                           ;K25 = trunc mask (UPA1)
2701 d    P:03F9 040000                            DC      $040000                           ;K26 = shift const (FILTA)
2702 d    P:03FA FFF800                            DC      $FFF800                           ;K27 = trunc mask (FILTA)
2703 d    P:03FB FFFE00                            DC      $FFFE00                           ;K28 = trunc mask (FILTB)
2704 d    P:03FC FFE000                            DC      $FFE000                           ;K29 = trunc mask (FILTC)
2705 d    P:03FD FFFC00                            DC      $FFFC00                           ;K30 = trunc mask (FILTD)
2706 d    P:03FE 088000                            DC      $088000                           ;K31 = '1.06' (LIMB)
2707 d    P:03FF FFFC00                            DC      $FFFC00                           ;K32 = trunc mask (FILTE)
0    Errors
0    Warnings





