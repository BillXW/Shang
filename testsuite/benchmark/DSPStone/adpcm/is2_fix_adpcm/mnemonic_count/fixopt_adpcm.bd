:SBD.371410569{
16
0
16
0
0
0
0
0
48
24
:SBlock.41338505{
16
1
:SBInPort.1568323725{
16
1
@2
1
1
:CDecl.9{
1
:String.9{
11
19
"int *INPUT;"
}
}
:CExpr.138{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
5
6
"INPUT"
}
-1
1
:SArc.73{
16
1
@3
1
:SBOutPort.1568323725{
16
1
#2{
16
3
#3{
16
1
@10
1
1
#4{
1
#5{
17
24
"register int *DQ;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
2
3
"DQ"
}
-1
1
#7{
16
1
@11
1
#8{
16
1
#2{
16
1
#3{
16
1
@18
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@7
-1
1
#7{
16
1
@19
1
#8{
16
1
#2{
16
2
#3{
16
1
@25
1
1
#4{
1
#5{
16
24
"register int *I;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"I"
}
-1
1
#7{
16
1
@26
1
#8{
16
1
#2{
16
1
#3{
16
1
@33
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@7
-1
1
#7{
16
1
@34
1
#8{
16
1
#2{
16
2
#3{
16
1
@40
1
1
#4{
1
#5{
16
24
"register int *D;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"D"
}
-1
1
#7{
16
1
@41
1
#8{
16
1
#2{
16
2
#3{
16
1
@48
1
1
#4{
1
#5{
17
24
"register int *SL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
2
3
"SL"
}
-1
1
#7{
16
1
@49
1
#8{
16
1
#2{
16
0
16
1
@55
0
1
0
0
@1
1
1
1
0
:SMIdent.9{
1
0
1
1
1
1
0
0
1
1
#5{
9
10
"CONST_INT"
}
#5{
73
89
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/const_int.gc"
}
#5{
9
25
"const_int"
}
#5{
9
25
"const_int"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
1
16
"8"
}
}
:SBKernel.73{
0
0
0
0
0
0
0
1
0
0
:SBCode.73{
11
1
1
1
0
0
#5{
4
20
"void"
}
#5{
9
25
"const_int"
}
#5{
31
48
"\n\n  *Output = ConstantValue; \n\n"
}
0
}
0
0
0
}
:SMParamCl.1097{
16
1
:SBParam.73{
1
#4{
1
#5{
27
53
"register int ConstantValue;"
}
}
1
1
1
1
#5{
1
17
"1"
}
#5{
13
29
"CONSTANTVALUE"
}
-1
}
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
21
24
"register int *Output;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
6
7
"OUTPUT"
}
-1
1
@54
}
1
1
0
0
1
#5{
10
11
"SIG_0034_2"
}
#5{
10
26
"SIG_0034_2"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
:ELongCl.1097{
16
1
:ELong.9{
0
}
}
#14{
16
1
#15{
0
}
}
:StringClCl.1097{
16
1
:StringCl.1097{
16
0
}
}
}
}
#3{
16
1
@48
1
1
#4{
1
#5{
17
24
"register int *SE;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
2
3
"SE"
}
-1
1
#7{
16
1
@91
1
#8{
16
1
#2{
16
2
#3{
16
1
@98
1
1
#4{
1
#5{
17
24
"register int *DQ;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
2
3
"DQ"
}
-1
1
#7{
16
1
@99
1
#8{
16
1
@18
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
@104
}
1
1
0
0
1
#5{
8
9
"SIG_0053"
}
#5{
8
24
"SIG_0053"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
#3{
16
1
@98
1
1
#4{
1
#5{
16
24
"register int *T;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
1
2
"T"
}
-1
1
#7{
16
1
@121
1
#8{
16
1
@2
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
@126
}
1
1
0
0
1
#5{
8
9
"SIG_0055"
}
#5{
8
24
"SIG_0055"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
16
2
@97
#8{
16
1
@98
1
1
#4{
1
#5{
18
24
"register int *A_2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
3
4
"A_2"
}
-1
1
#7{
16
1
#3{
16
1
@10
1
1
#4{
1
#5{
18
24
"register int *A_2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
3
4
"A_2"
}
-1
1
@148
}
1
@143
1
1
0
0
1
#5{
8
9
"SIG_0005"
}
#5{
8
24
"SIG_0005"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
12
13
"ADPT_PREDICT"
}
#5{
76
92
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/adpt_predict.gc"
}
#5{
12
28
"adpt_predict"
}
#5{
12
28
"adpt_predict"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"20"
}
}
#10{
0
1
1
0
0
0
0
1
0
0
:SMStateCl.1097{
16
14
:SBState.73{
1
#4{
1
#5{
8
19
"int DQ2;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ3;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ4;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ5;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ6;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ7;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int PK1;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int PK2;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int SR2;"
}
}
}
#19{
1
#4{
1
#5{
7
19
"int A1;"
}
}
}
#19{
1
#4{
1
#5{
7
19
"int A2;"
}
}
}
#19{
1
#4{
1
#5{
12
19
"int B [ 6 ];"
}
}
}
#19{
1
#4{
1
#5{
7
19
"int SE;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int SEZ;"
}
}
}
}
#17{
16
2
#5{
55
71
"#include \"/tools/home1/dsp/dsp56k/is2_includes/fmult.h\""
}
#5{
19
35
"#include \"xcepts.h\""
}
}
#11{
32
1
1
1
0
0
#5{
4
20
"void"
}
#5{
12
28
"adpt_predict"
}
#5{
3391
3403
"\n  register int DQS, DQI, DQSEZ, PK0 ; \n  register int SR1;\n  register int A
1S, AP;\t\n  register int A2R ;\t\n  register int WA1, WA2;\n  register int MAG,
 EXP, MANT ; \n  int BP[6]; \n  \n  /* ADDC */\n  DQS = *DQ >> 14;\n  DQI = DQS 
== 0 ? *DQ : (65536 - (*DQ & 16383)) & 65535;\n  MAG = ((SEZ >> 14) == 0) ? SEZ 
: (1 << 15) + SEZ;\n  DQSEZ = (DQI + MAG) & 65535;\n  PK0 = DQSEZ >> 15;\n  WA2 
= DQSEZ == 0 ? 1 : 0;\n  \n  /* ADDB */\n  DQI = DQS == 0 ? *DQ : (65536 - (*DQ 
& 16383)) & 65535;\n  MAG = ((SE >> 14) == 0) ? SE : (1 << 15) + SE;\n  DQSEZ = 
(DQI + MAG) & 65535;\n  \n  /* FLOATB */\n  MAG = ((DQSEZ >> 15) == 0) ? DQSEZ :
 (65536 - DQSEZ) & 32767;\n  for (EXP = 0; (MAG >> EXP) != 0; EXP++)\n    ;\n  M
ANT = MAG == 0 ? 1 << 5 : (MAG << 6) >> EXP;\n  SR1 = ( (DQSEZ >> 15) << 10)  + 
(EXP << 6) + MANT;\n  \n  /* UPA2 */\n  WA1 = PK0 ^ PK1;\n  MAG = (PK0 ^ PK2) ==
 0 ? 16384 : 114688;\n  A1S = A1 >> 15;\n  if (A1S == 0)\n    EXP = A1 <= 8191 ?
 A1 << 2 : 8191 << 2;\n  else\n    EXP = A1 >= 57345 ? (A1 << 2) & 131071 : 2457
7 << 2;\n  EXP = WA1 == 1 ? EXP : (131072 - EXP) & 131071;\n  MAG = (MAG + EXP) 
& 131071;\n  EXP = WA2 == 1 ? 0 :\n    ( (MAG >> 16) == 0)  ? MAG >> 7 : (MAG >>
 7) + 64512;\n  MANT = (A2 >> 15) == 0 ? (65536 - (A2 >> 7)) & 65535 :\n    (655
36 - ((A2 >> 7) + 65024)) & 65535;\n  EXP = (EXP + MANT) & 65535;\n  EXP = (A2 +
 EXP) & 65535;\n  \n  /* LIMC */\n  AP = 32768 <= EXP && EXP <= 53248 ? 53248 :
\n    12288 <= EXP && EXP <= 32767 ? 12288 : EXP;\n  \n  /* TRIGB */\n  A2R = *T
 == 0 ? AP : 0;\n  \n  /* UPA1 */\n  EXP = WA2 == 1 ? 0 : (WA1 == 0 ? 192 : 6534
4);\n  MANT = A1S == 0 ? (65536 - (A1 >> 8)) & 65535 :\n    (65536 - ((A1 >> 8) 
+ 65280)) & 65535;\n  EXP = (EXP + MANT) & 65535;\n  EXP = (A1 + EXP) & 65535;\n
  \n  /* FMULT */\n  WA2 = fmult(A2R, SR2) ; \n \n  /* LIMD */\n  MAG = (15360 +
 65536 - AP) & 65535;\n  A1 = (AP + 65536 - 15360) & 65535;\n  AP = 32768 <= EXP
 && EXP <= A1 ? A1 :\n    MAG <= EXP && EXP <= 32767 ? MAG : EXP;\n  \n  /* TRIG
B */\n  A1 = *T == 0 ? AP : 0;\n  \n  /* FMULT */\n  WA1 = fmult(A1, SR1);\n  \n
  /* FLOATA */\n  MAG = *DQ & 16383;\n  for (EXP = 0; (MAG >> EXP) != 0; EXP++)
\n    ;\n  MANT = MAG == 0 ? 1 << 5 : (MAG << 6) >> EXP;\n  DQSEZ = (DQS << 10) 
+ (EXP << 6) + MANT;\n  \n  /* XOR */\n  BP[0] = DQS ^ (DQ2 >> 10);\n  BP[1] = D
QS ^ (DQ3 >> 10);\n  BP[2] = DQS ^ (DQ4 >> 10);\n  BP[3] = DQS ^ (DQ5 >> 10);\n 
 BP[4] = DQS ^ (DQ6 >> 10);\n  BP[5] = DQS ^ (DQ7 >> 10);\n  \n  /* UPB */\n  MA
NT = *DQ & 16383;\n  for (EXP = 0; EXP < 6; EXP++)\n    \[\n      DQS = MANT == 
0 ? 0 : (BP[EXP] == 0 ? 128 : 65408);\n      MAG = B[EXP] >> 15;\n      DQS += M
AG == 0 ? (65536 - (B[EXP] >> 8)) & 65535 :\n\t(65536 - ((B[EXP] >> 8) + 65280))
 & 65535;\n      DQS &= 65535;\n      BP[EXP] = (B[EXP] + DQS) & 65535;\n    \]
\n  \n  /* TRIGB */\n  if (*T != 0)\n    for (EXP = 0; EXP < 6; EXP++)\n      BP
[EXP] = 0 ;\n  \n  /* FMULT */\n  DQI  = fmult(BP[0], DQSEZ);\n  MAG  = fmult(BP
[1], DQ2);\n  MANT = fmult(BP[2], DQ3);\n  A1S  = fmult(BP[3], DQ4);\n  AP   = f
mult(BP[4], DQ5);\n  EXP  = fmult(BP[5], DQ6);\n  \n  /* ACCUM */\n  DQS = (((((
((((DQI + MAG) & 65535) + MANT) & 65535)\n\t      + A1S) & 65535) + AP) & 65535)
 + EXP) & 65535;\n  SEZ = DQS >> 1;\n  *S_E = SE = ( (((DQS + WA2) & 65535) + WA
1) & 65535 )>> 1;\n  \n  /* STATE update */\n  PK2 = PK1;\n  PK1 = PK0;\n  SR2 =
 SR1;\n  *A_2 = A2 = A2R;\n\n  for (EXP = 0; EXP < 6; EXP++)\n    B[EXP] = BP[EX
P];\n\n  DQ7 = DQ6;\n  DQ6 = DQ5;\n  DQ5 = DQ4;\n  DQ4 = DQ3;\n  DQ3 = DQ2;\n  D
Q2 = DQSEZ;\n  \t\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
18
24
"register int *S_E;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
3
4
"S_E"
}
-1
1
@96
}
1
1
0
0
1
#5{
8
9
"SIG_0004"
}
#5{
8
24
"SIG_0004"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
1
@47
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
11
12
"DIFF_SIGNAL"
}
#5{
75
91
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/diff_signal.gc"
}
#5{
11
27
"diff_signal"
}
#5{
11
27
"diff_signal"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
1
16
"5"
}
}
#10{
0
0
0
0
0
0
0
1
0
0
#11{
13
1
1
1
0
0
#5{
4
20
"void"
}
#5{
11
27
"diff_signal"
}
#5{
149
155
"\n  \t\t\n  /* SUBTA */\n  *SL  = *SL & (1 << 13) ? 49152 | *SL : *SL;\n  *SE  
= *SE & (1 << 14) ? 32768 | *SE : *SE;\n  *D = (*SL + 65536 - *SE) & 65535;\n\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
16
24
"register int *D;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"D"
}
-1
1
@46
}
1
1
0
0
1
#5{
8
9
"SIG_0031"
}
#5{
8
24
"SIG_0031"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@40
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
1
2
"Y"
}
-1
1
#7{
16
1
@266
1
#8{
16
1
#2{
16
1
#3{
16
1
@273
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@7
-1
1
#7{
16
1
@274
1
#8{
16
1
#2{
16
2
#3{
16
1
@280
1
1
#4{
1
#5{
16
24
"register int *L;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"L"
}
-1
1
#7{
16
1
@281
1
#8{
16
1
@33
1
1
#4{
1
#5{
13
19
"int *OUTPUT4;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
4
1
#5{
7
22
"OUTPUT4"
}
-1
1
@286
}
1
1
0
0
1
#5{
8
9
"SIG_0048"
}
#5{
8
24
"SIG_0048"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@280
1
1
#4{
1
#5{
17
24
"register int *AL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
2
3
"AL"
}
-1
1
#7{
16
1
@302
1
#8{
16
1
#2{
16
4
#3{
16
1
@309
1
1
#4{
1
#5{
16
24
"register int *L;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"L"
}
-1
1
#7{
16
1
@310
1
#8{
16
1
@33
1
1
#4{
1
#5{
13
19
"int *OUTPUT5;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
5
1
#5{
7
22
"OUTPUT5"
}
-1
1
@315
}
1
1
0
0
1
#5{
8
9
"SIG_0049"
}
#5{
8
24
"SIG_0049"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@309
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
1
2
"Y"
}
-1
1
#7{
16
1
@331
1
#8{
16
1
@273
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
@336
}
1
1
0
0
1
#5{
10
11
"SIG_0038_1"
}
#5{
10
26
"SIG_0038_1"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@309
1
1
#4{
1
#5{
17
24
"register int *TR;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
#5{
2
3
"TR"
}
-1
1
#7{
16
1
@352
1
#8{
16
1
@2
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
@357
}
1
1
0
0
1
#5{
8
9
"SIG_0054"
}
#5{
8
24
"SIG_0054"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@309
1
1
#4{
1
#5{
18
24
"register int *TDP;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
4
1
#5{
2
3
"TD"
}
-1
1
#7{
16
1
@373
1
#8{
16
1
@10
1
1
#4{
1
#5{
19
24
"register int *T_DP;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
4
5
"T_DP"
}
-1
1
@378
}
1
1
0
0
1
#5{
8
9
"SIG_0008"
}
#5{
8
24
"SIG_0008"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
1
@308
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
13
14
"SPEED_CONTROL"
}
#5{
77
93
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/speed_control.gc"
}
#5{
13
29
"speed_control"
}
#5{
13
29
"speed_control"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"14"
}
}
#10{
0
1
0
0
0
0
0
1
0
0
#18{
16
3
#19{
1
#4{
1
#5{
17
24
"register int DMS;"
}
}
}
#19{
1
#4{
1
#5{
17
24
"register int DML;"
}
}
}
#19{
1
#4{
1
#5{
16
24
"register int AP;"
}
}
}
}
#11{
16
1
1
1
0
0
#5{
4
20
"void"
}
#5{
13
29
"speed_control"
}
#5{
1473
1481
"\n  static int F[] = \[ 0, 0, 0, 1, 1, 1, 3, 7 \];\n  register int FI, tmp ; \n
\n  /* FUNTCF */\n  \n  FI = F[(*L >> 3 ? (15 - *L) : *L) & 7] ; \n\n  /* FILTA 
routine \n     Update of the short term average of F[l] */\n\n  tmp = ( (FI<<9) 
+ 8192 - DMS ) & 8191 ; \n  tmp = (tmp >> 12) ? (tmp >> 5) + 3840 : (tmp >> 5) ;
\n  DMS = (tmp + DMS) & 4095 ;  \n\n  /* FILTB routine \n     Update of the long
 term average of F[l] */\n\n  tmp = ( (FI<<11) + 32768 - DML ) & 32767 ; \n  tmp
 = (tmp >> 14) ? (tmp >> 7) + 16128 : (tmp >> 7) ;\n  DML = (tmp + DML) & 16383 
; \n\n  /* SUBTC routine */\n  /* Compute magnitude of the difference of short a
nd long term functions\n   of quantizer output sequence and then perform thresho
ld comparison\n   for quantizing speed control parameter \n  */\n\n  tmp = ( (DM
S << 2) + 32768  - DML ) & 32767  ;\n  tmp = (tmp >> 14) ? (32768 - tmp) & 16383
 : tmp ; \n\n  /* FI is now the speed control parameter update */\n  /* 1536 d =
 0011000000000 for SM 13 (3.-9) is 3 */\n\n  FI = ( (*Y >= 1536) && (tmp < (DML 
>> 3) ) && ((*TDP & 0x1) == 0) ) \n       ? 0 : 1;\n\n /* FILTC : low pass filte
r of speed control parameter */\n \n  tmp = ((FI << 9) + 2048 - AP) & 2047 ; \n 
 tmp = (tmp >> 10) ? (tmp >> 4) & 896 : (tmp >> 4) ; \n  tmp = (tmp + AP) & 1023
 ; \n\n /* TRIGA: Speed control trigger funcion */\n\n  AP = ((*TR & 0x1) == 1) 
?  256 : tmp ; \n\n  /* G.721 recommendation p.250 (LIMA Function) */\n  /* 256 
= 0100000000 bin = 1 for a 10SM 1.-8 value */\n\n  *AL = (AP > 255) ? 64 : AP >>
 2; \n\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
17
24
"register int *AL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
2
3
"AL"
}
-1
1
@307
}
1
1
0
0
1
#5{
10
11
"SIG_0021_1"
}
#5{
10
26
"SIG_0021_1"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
2
@279
#8{
16
1
@280
1
1
#4{
1
#5{
17
24
"register int *YL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
2
3
"YL"
}
-1
1
#7{
16
1
#3{
16
1
@10
1
1
#4{
1
#5{
17
24
"register int *YL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
#5{
2
3
"YL"
}
-1
1
@437
}
1
@432
1
1
0
0
1
#5{
8
9
"SIG_0022"
}
#5{
8
24
"SIG_0022"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
12
13
"SCALE_FACTOR"
}
#5{
76
92
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/scale_factor.gc"
}
#5{
12
28
"scale_factor"
}
#5{
12
28
"scale_factor"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
1
16
"7"
}
}
#10{
0
1
0
0
0
0
0
1
0
0
#18{
16
2
#19{
1
#4{
1
#5{
17
24
"register int Y_L;"
}
}
}
#19{
1
#4{
1
#5{
20
24
"register int LAST_Y;"
}
}
}
}
#11{
15
1
1
1
0
0
#5{
4
20
"void"
}
#5{
12
28
"scale_factor"
}
#5{
1373
1381
"\n  static int W[] = \n    \[\n      4084, 18, 41, 64, 112, 198, 255, 1122\n   
 \] ; \n  \n  register int TMP, YUP, YLP ;\n  \n  /* FUNCTW, map quantizer outpu
t into \n     logarithmic version of scale factor multiplier */\n  \n  TMP = W[(
*L>>3) ? (15-*L) & 7 : *L & 7] ;\n  \n  /* FILTD, update of fast quantizer scale
 factor */\n  \n  TMP = ((TMP<<5) + 131072 - LAST_Y) & 131071 ; \n  YUP = (TMP>>
16) ? (TMP>>5) + 4096 : (TMP>>5) ; \n  YUP = (YUP + LAST_Y) & 8191 ; \n  \n  /* 
LIMB, limit quantizer scale factor */\n  \n    /* Set upper limit to 10.0 */\n  
if (( ( (YUP + 11264) & 16383) >> 13) == 0) YUP = 5120 ; \n    /* Set lower limi
t to 1.06 */\n  if (( ( (YUP + 15840) & 16383) >> 13) == 1) YUP = 544  ; \n  \n 
 /* FILTE, update of slow quantizer scale factor */\n  \n  TMP = (YUP + ((104857
6 - Y_L) >> 6)) & 16383 ; \n  TMP = (TMP >> 13) ? TMP + 507904 : TMP ; \n  YLP =
 (TMP + Y_L) & 524287 ; \n  \n  /* MIX, form linear combination of fast and slow
 quantizer scale factors */\n  \n  TMP    = (YUP + 16384 - (Y_L >> 6)) & 16383 ;
 \n  LAST_Y =  TMP >> 13 ; /* LAST_Y is used here as a temp variable */\n  TMP  
  = (LAST_Y == 1) ? (16384 - TMP) & 8191  : TMP ; \n  TMP    = (TMP * *AL) >> 6 
; \n  TMP    = (LAST_Y == 1) ? (16384 - TMP) & 16383 : TMP ; \n  \n  /* calculat
e new Y */\n  /* Output samples */\n  /* Store new states */\n \n  LAST_Y = *Y =
 ((Y_L >> 6) + TMP) & 8191 ; \n  *YL = Y_L ; \n  Y_L = YLP ;\n\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"Y"
}
-1
1
@278
}
1
1
0
0
1
#5{
8
9
"SIG_0032"
}
#5{
8
24
"SIG_0032"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
16
3
@272
@337
#8{
16
1
@273
1
1
#4{
1
#5{
13
19
"int *OUTPUT3;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
#5{
7
22
"OUTPUT3"
}
-1
1
#7{
16
1
#3{
16
1
@25
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
1
2
"Y"
}
-1
1
@495
}
1
@490
1
1
0
0
1
#5{
8
9
"SIG_0039"
}
#5{
8
24
"SIG_0039"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"12"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
95
122
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n    *OUTPUT3++ =\n      *
INPUT++ ;\n  ENDLOOP\n"
}
:SMLoopCl.1097{
16
1
:SBLoop.73{
1
1
0
0
0
0
@518
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
@271
}
1
1
0
0
1
#5{
10
11
"SIG_0037_1"
}
#5{
10
26
"SIG_0037_1"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
1
@39
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
10
11
"ADPT_QUANT"
}
#5{
74
90
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/adpt_quant.gc"
}
#5{
10
26
"adpt_quant"
}
#5{
10
26
"adpt_quant"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"31"
}
}
#10{
0
0
0
0
0
0
0
1
0
0
#11{
12
1
1
1
0
0
#5{
4
20
"void"
}
#5{
10
26
"adpt_quant"
}
#5{
740
743
"\n  register int DS, DLN, EXP;\n \n  /* LOG */\n  DS = *D & (1 << 15);\n  DLN =
 DS ? (65536 - *D) & 32767 : *D;\n  for (EXP = 1; DLN >> EXP; EXP++)\n    ;\n  E
XP--;\n  DLN = (EXP * (1 << 7)) + (((DLN * (1 << 7)) >> EXP) & 127);\n  \n  /* S
UBTB */\n  DLN = (DLN + 4096 - (*Y >> 2)) & 4095;\n  \n  /* QUAN */\n  if (DLN >
 3971)\n    *I = DS ? 0xE : 0x1;\n  else \n    if (DLN > 2047) \n      *I = 0xF;
\n    else \n      if (DLN > 399)\n\t*I = DS ? 0x8 : 0x7;\n      else \n\tif (DL
N > 348)\n\t  *I = DS ? 0x9 : 0x6;\n\telse \n\t  if (DLN > 299)\n\t    *I = DS ?
 0xA : 0x5;\t\n\t  else \n\t    if (DLN > 245)\n\t      *I = DS ? 0xB : 0x4;\n\t
    else \n\t      if (DLN > 177)\n\t\t*I = DS ? 0xC : 0x3;\n\t      else \n\t\t
if (DLN > 79)\n\t\t  *I = DS ? 0xD : 0x2;\n\t\telse\n\t\t  *I = DS ? 0xE : 0x1;
\n  \n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
16
24
"register int *I;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"I"
}
-1
1
@38
}
1
1
0
0
1
#5{
8
9
"SIG_0028"
}
#5{
8
24
"SIG_0028"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
7
#8{
16
1
@33
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
#7{
16
1
#3{
16
1
#2{
16
2
@575
#3{
16
1
@576
1
1
#4{
1
#5{
17
24
"register int *AL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@306
-1
1
#7{
16
1
@577
1
#8{
16
1
#2{
16
4
#3{
16
1
@583
1
1
#4{
1
#5{
16
24
"register int *L;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@314
-1
1
#7{
16
1
@584
1
#8{
16
1
@33
1
1
#4{
1
#5{
13
19
"int *OUTPUT3;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
#5{
7
22
"OUTPUT3"
}
-1
1
@588
}
1
1
0
0
1
#5{
8
9
"SIG_0047"
}
#5{
8
24
"SIG_0047"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@583
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@335
-1
1
#7{
16
1
@604
1
#8{
16
1
#2{
16
1
#3{
16
1
@610
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@7
-1
1
#7{
16
1
@611
1
#8{
16
1
@576
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@478
-1
1
@615
}
1
1
0
0
1
#5{
8
9
"SIG_0035"
}
#5{
8
24
"SIG_0035"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
16
3
#8{
16
1
@610
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
#7{
16
1
#3{
16
1
#2{
16
2
#3{
16
1
@638
1
1
#4{
1
#5{
16
24
"register int *I;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@30
-1
1
#7{
16
1
@639
1
#8{
16
1
@33
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
@643
}
1
1
0
0
1
#5{
8
9
"SIG_0046"
}
#5{
8
24
"SIG_0046"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@637
16
1
#8{
16
1
@638
1
1
#4{
1
#5{
17
24
"register int *DQ;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
2
3
"DQ"
}
-1
1
#7{
16
1
#3{
16
1
#2{
16
1
@665
16
3
#8{
16
1
@666
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
#7{
16
1
#3{
16
1
#2{
16
2
@673
#3{
16
1
@674
1
1
#4{
1
#5{
16
24
"register int *T;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@125
-1
1
#7{
16
1
@675
1
#8{
16
1
#2{
16
1
#3{
16
1
@681
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@7
-1
1
#7{
16
1
@682
1
#8{
16
1
#2{
16
3
#3{
16
1
@688
1
1
#4{
1
#5{
17
24
"register int *DQ;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@15
-1
1
#7{
16
1
@689
1
#8{
16
1
@666
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
@693
}
1
1
0
0
1
#5{
10
11
"SIG_0035_1"
}
#5{
10
26
"SIG_0035_1"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@688
1
1
#4{
1
#5{
18
24
"register int *A_2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@153
-1
1
#7{
16
1
@709
1
#8{
16
1
@674
1
1
#4{
1
#5{
18
24
"register int *A_2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@147
-1
1
@713
}
1
1
0
0
1
#5{
8
9
"SIG_0026"
}
#5{
8
24
"SIG_0026"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@688
1
1
#4{
1
#5{
17
24
"register int *YL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
@442
-1
1
#7{
16
1
@728
1
#8{
16
1
@576
1
1
#4{
1
#5{
17
24
"register int *YL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@436
-1
1
@732
}
1
1
0
0
1
#5{
10
11
"SIG_0034_3"
}
#5{
10
26
"SIG_0034_3"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
16
2
@687
#8{
16
1
@688
1
1
#4{
1
#5{
19
24
"register int *T_DP;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@383
-1
1
#7{
16
1
#3{
16
1
@583
1
1
#4{
1
#5{
18
24
"register int *TDP;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
4
1
@377
-1
1
@752
}
1
@748
1
1
0
0
1
#5{
8
9
"SIG_0038"
}
#5{
8
24
"SIG_0038"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
13
14
"TONE_DETECTOR"
}
#5{
77
93
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/tone_detector.gc"
}
#5{
13
29
"tone_detector"
}
#5{
13
29
"tone_detector"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"42"
}
}
#10{
0
1
0
0
0
0
0
1
0
0
#18{
16
2
#19{
1
#4{
1
#5{
18
24
"register int t_dr;"
}
}
}
#19{
1
#4{
1
#5{
21
24
"register int LAST_TR;"
}
}
}
}
#11{
14
1
1
1
0
0
#5{
4
20
"void"
}
#5{
13
29
"tone_detector"
}
#5{
545
556
"\n  register int tmp ; \n  register int t_d ; \n\n  /* partial band signal dete
ction */\n  *T_DP = ( (*A_2 > 32769) && (*A_2 < 53761) ) ? 1 : 0 ; \n  \n  /* ta
ke last t_dr */\n  t_d = t_dr ;\n  \n  /* calcutale new t_dr */\n  /* TRIGB Func
tion */\n  t_dr = (LAST_TR == 0) ? *T_DP : 0 ; \n  \n  LAST_TR = *YL >> 15 ; /* 
LAST_TR is used here as a temporary variable */\n  \n  tmp = (LAST_TR > 8) ? \n 
   31 << 9 : (32 + ((LAST_TR << 5) & 31)) << LAST_TR ; \n  \n  LAST_TR = *TR = (
 ((*DQ & 16383) > (tmp + (tmp >> 1) ) >> 1) \n\t\t   && (t_d == 1) )  ?  \n\t\t 
    1 : 0;\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
17
24
"register int *TR;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
2
3
"TR"
}
-1
1
@686
}
1
1
0
0
1
#5{
8
9
"SIG_0037"
}
#5{
8
24
"SIG_0037"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
2
@680
#8{
16
1
@681
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
#7{
16
1
#3{
16
1
@583
1
1
#4{
1
#5{
17
24
"register int *TR;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
@356
-1
1
@807
}
1
@802
1
1
0
0
1
#5{
10
11
"SIG_0033_2"
}
#5{
10
26
"SIG_0033_2"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
1
16
"9"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
78
80
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n      *INPUT++ ;\n  ENDLO
OP\n"
}
#20{
16
1
#21{
1
1
0
0
0
0
@829
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
@679
}
1
1
0
0
1
#5{
10
11
"SIG_0032_1"
}
#5{
10
26
"SIG_0032_1"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
16
2
#8{
16
1
@674
1
1
#4{
1
#5{
18
24
"register int *S_E;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@227
-1
1
#7{
16
1
#3{
16
1
#2{
16
1
@858
16
2
#8{
16
1
@859
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
#7{
16
1
#3{
16
1
#2{
16
2
#3{
16
1
@867
1
1
#4{
1
#5{
21
24
"register int *AddIn1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
6
7
"ADDIN1"
}
-1
1
#7{
16
1
@868
1
#8{
16
1
@666
1
1
#4{
1
#5{
13
19
"int *OUTPUT3;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
#5{
7
22
"OUTPUT3"
}
-1
1
@873
}
1
1
0
0
1
#5{
8
9
"SIG_0036"
}
#5{
8
24
"SIG_0036"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@866
16
1
#8{
16
1
@867
1
1
#4{
1
#5{
21
24
"register int *AddOut;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
6
7
"ADDOUT"
}
-1
1
#7{
16
1
#3{
16
1
#2{
16
4
#3{
16
1
@896
1
1
#4{
1
#5{
16
24
"register int *L;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
1
2
"L"
}
-1
1
#7{
16
1
@897
1
#8{
16
1
@33
1
1
#4{
1
#5{
13
19
"int *OUTPUT7;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
7
1
#5{
7
22
"OUTPUT7"
}
-1
1
@902
}
1
1
0
0
1
#5{
8
9
"SIG_0051"
}
#5{
8
24
"SIG_0051"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@895
#3{
16
1
@896
1
1
#4{
1
#5{
17
24
"register int *SE;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
#5{
2
3
"SE"
}
-1
1
#7{
16
1
@918
1
#8{
16
1
@859
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
@923
}
1
1
0
0
1
#5{
8
9
"SIG_0044"
}
#5{
8
24
"SIG_0044"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
#3{
16
1
@896
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
4
1
#5{
1
2
"Y"
}
-1
1
#7{
16
1
@939
1
#8{
16
1
@610
1
1
#4{
1
#5{
13
19
"int *OUTPUT3;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
3
1
#5{
7
22
"OUTPUT3"
}
-1
1
@944
}
1
1
0
0
1
#5{
8
9
"SIG_0042"
}
#5{
8
24
"SIG_0042"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
1
#8{
16
1
@896
1
1
#4{
1
#5{
17
24
"register int *SD;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
2
3
"SD"
}
-1
1
#7{
16
1
#3{
16
1
#2{
16
1
@966
16
0
0
1
0
0
@1
1
0
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"KILL_I"
}
#5{
4
20
"kill"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"37"
}
}
1
0
#5{
6
22
"SIGNAL"
}
1
0
1
}
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
5
21
"INPUT"
}
-1
1
@965
}
1
@960
1
1
0
0
1
#5{
8
9
"SIG_0043"
}
#5{
8
24
"SIG_0043"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
10
11
"CODING_ADJ"
}
#5{
74
90
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/coding_adj.gc"
}
#5{
10
26
"coding_adj"
}
#5{
10
26
"coding_adj"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"24"
}
}
#10{
0
0
0
0
0
0
0
1
0
0
#11{
11
1
1
1
0
0
#5{
4
20
"void"
}
#5{
10
26
"coding_adj"
}
#5{
22
38
"\n\t*SD = *SP & 0x7FFF;\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
17
24
"register int *SP;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
2
3
"SP"
}
-1
1
@894
}
1
@889
1
1
0
0
1
#5{
10
11
"SIG_0012_1"
}
#5{
10
26
"SIG_0012_1"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
3
4
"ADD"
}
#5{
67
83
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/add.gc"
}
#5{
3
19
"add"
}
#5{
3
19
"add"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
1
16
"6"
}
}
#10{
0
0
0
0
0
0
0
1
0
0
#11{
11
1
1
1
0
0
#5{
4
20
"void"
}
#5{
3
19
"add"
}
#5{
441
442
"\n/* 15 SM auf 16 TC */\n\n    *AddIn1 = (*AddIn1 & (1 << 14)) ? *AddIn1 == (1 
<< 14) ? 0: \n              (((*AddIn1 ^ 0x3FFF) + 0x1) & 0x3FFF) + 0xC000 : *Ad
dIn1 ; \n\n/* 15 TC auf 16 TC */\n\n    *AddIn2 = (*AddIn2 & (1 << 14)) ? 0x8000
 + *AddIn2 : *AddIn2 ; \n\n/* perform add operation at 16 TC */\n\n    *AddOut  
= (*AddIn1 + *AddIn2) & 0xffff;\n\n    /* Output conversions */\n\n    *AddOut =
 (*AddOut & 0x8000) ? 0xFFFF0000 | *AddOut : *AddOut  ; \n\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
21
24
"register int *AddIn2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
6
7
"ADDIN2"
}
-1
1
@865
}
1
@860
1
1
0
0
1
#5{
10
11
"SIG_0043_1"
}
#5{
10
26
"SIG_0043_1"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@924
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"15"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
78
80
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n      *INPUT++ ;\n  ENDLO
OP\n"
}
#20{
16
1
#21{
1
1
0
0
0
0
@1052
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@7
-1
1
@857
}
1
@853
1
1
0
0
1
#5{
8
9
"SIG_0019"
}
#5{
8
24
"SIG_0019"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@714
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
12
13
"ADPT_PREDICT"
}
#5{
76
92
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/adpt_predict.gc"
}
#5{
12
28
"adpt_predict"
}
#5{
12
28
"adpt_predict"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"10"
}
}
#10{
0
1
1
0
0
0
0
1
0
0
#18{
16
14
#19{
1
#4{
1
#5{
8
19
"int DQ2;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ3;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ4;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ5;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ6;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int DQ7;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int PK1;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int PK2;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int SR2;"
}
}
}
#19{
1
#4{
1
#5{
7
19
"int A1;"
}
}
}
#19{
1
#4{
1
#5{
7
19
"int A2;"
}
}
}
#19{
1
#4{
1
#5{
12
19
"int B [ 6 ];"
}
}
}
#19{
1
#4{
1
#5{
7
19
"int SE;"
}
}
}
#19{
1
#4{
1
#5{
8
19
"int SEZ;"
}
}
}
}
#17{
16
2
#5{
55
71
"#include \"/tools/home1/dsp/dsp56k/is2_includes/fmult.h\""
}
#5{
19
35
"#include \"xcepts.h\""
}
}
#11{
32
1
1
1
0
0
#5{
4
20
"void"
}
#5{
12
28
"adpt_predict"
}
#5{
3391
3403
"\n  register int DQS, DQI, DQSEZ, PK0 ; \n  register int SR1;\n  register int A
1S, AP;\t\n  register int A2R ;\t\n  register int WA1, WA2;\n  register int MAG,
 EXP, MANT ; \n  int BP[6]; \n  \n  /* ADDC */\n  DQS = *DQ >> 14;\n  DQI = DQS 
== 0 ? *DQ : (65536 - (*DQ & 16383)) & 65535;\n  MAG = ((SEZ >> 14) == 0) ? SEZ 
: (1 << 15) + SEZ;\n  DQSEZ = (DQI + MAG) & 65535;\n  PK0 = DQSEZ >> 15;\n  WA2 
= DQSEZ == 0 ? 1 : 0;\n  \n  /* ADDB */\n  DQI = DQS == 0 ? *DQ : (65536 - (*DQ 
& 16383)) & 65535;\n  MAG = ((SE >> 14) == 0) ? SE : (1 << 15) + SE;\n  DQSEZ = 
(DQI + MAG) & 65535;\n  \n  /* FLOATB */\n  MAG = ((DQSEZ >> 15) == 0) ? DQSEZ :
 (65536 - DQSEZ) & 32767;\n  for (EXP = 0; (MAG >> EXP) != 0; EXP++)\n    ;\n  M
ANT = MAG == 0 ? 1 << 5 : (MAG << 6) >> EXP;\n  SR1 = ( (DQSEZ >> 15) << 10)  + 
(EXP << 6) + MANT;\n  \n  /* UPA2 */\n  WA1 = PK0 ^ PK1;\n  MAG = (PK0 ^ PK2) ==
 0 ? 16384 : 114688;\n  A1S = A1 >> 15;\n  if (A1S == 0)\n    EXP = A1 <= 8191 ?
 A1 << 2 : 8191 << 2;\n  else\n    EXP = A1 >= 57345 ? (A1 << 2) & 131071 : 2457
7 << 2;\n  EXP = WA1 == 1 ? EXP : (131072 - EXP) & 131071;\n  MAG = (MAG + EXP) 
& 131071;\n  EXP = WA2 == 1 ? 0 :\n    ( (MAG >> 16) == 0)  ? MAG >> 7 : (MAG >>
 7) + 64512;\n  MANT = (A2 >> 15) == 0 ? (65536 - (A2 >> 7)) & 65535 :\n    (655
36 - ((A2 >> 7) + 65024)) & 65535;\n  EXP = (EXP + MANT) & 65535;\n  EXP = (A2 +
 EXP) & 65535;\n  \n  /* LIMC */\n  AP = 32768 <= EXP && EXP <= 53248 ? 53248 :
\n    12288 <= EXP && EXP <= 32767 ? 12288 : EXP;\n  \n  /* TRIGB */\n  A2R = *T
 == 0 ? AP : 0;\n  \n  /* UPA1 */\n  EXP = WA2 == 1 ? 0 : (WA1 == 0 ? 192 : 6534
4);\n  MANT = A1S == 0 ? (65536 - (A1 >> 8)) & 65535 :\n    (65536 - ((A1 >> 8) 
+ 65280)) & 65535;\n  EXP = (EXP + MANT) & 65535;\n  EXP = (A1 + EXP) & 65535;\n
  \n  /* FMULT */\n  WA2 = fmult(A2R, SR2) ; \n \n  /* LIMD */\n  MAG = (15360 +
 65536 - AP) & 65535;\n  A1 = (AP + 65536 - 15360) & 65535;\n  AP = 32768 <= EXP
 && EXP <= A1 ? A1 :\n    MAG <= EXP && EXP <= 32767 ? MAG : EXP;\n  \n  /* TRIG
B */\n  A1 = *T == 0 ? AP : 0;\n  \n  /* FMULT */\n  WA1 = fmult(A1, SR1);\n  \n
  /* FLOATA */\n  MAG = *DQ & 16383;\n  for (EXP = 0; (MAG >> EXP) != 0; EXP++)
\n    ;\n  MANT = MAG == 0 ? 1 << 5 : (MAG << 6) >> EXP;\n  DQSEZ = (DQS << 10) 
+ (EXP << 6) + MANT;\n  \n  /* XOR */\n  BP[0] = DQS ^ (DQ2 >> 10);\n  BP[1] = D
QS ^ (DQ3 >> 10);\n  BP[2] = DQS ^ (DQ4 >> 10);\n  BP[3] = DQS ^ (DQ5 >> 10);\n 
 BP[4] = DQS ^ (DQ6 >> 10);\n  BP[5] = DQS ^ (DQ7 >> 10);\n  \n  /* UPB */\n  MA
NT = *DQ & 16383;\n  for (EXP = 0; EXP < 6; EXP++)\n    \[\n      DQS = MANT == 
0 ? 0 : (BP[EXP] == 0 ? 128 : 65408);\n      MAG = B[EXP] >> 15;\n      DQS += M
AG == 0 ? (65536 - (B[EXP] >> 8)) & 65535 :\n\t(65536 - ((B[EXP] >> 8) + 65280))
 & 65535;\n      DQS &= 65535;\n      BP[EXP] = (B[EXP] + DQS) & 65535;\n    \]
\n  \n  /* TRIGB */\n  if (*T != 0)\n    for (EXP = 0; EXP < 6; EXP++)\n      BP
[EXP] = 0 ;\n  \n  /* FMULT */\n  DQI  = fmult(BP[0], DQSEZ);\n  MAG  = fmult(BP
[1], DQ2);\n  MANT = fmult(BP[2], DQ3);\n  A1S  = fmult(BP[3], DQ4);\n  AP   = f
mult(BP[4], DQ5);\n  EXP  = fmult(BP[5], DQ6);\n  \n  /* ACCUM */\n  DQS = (((((
((((DQI + MAG) & 65535) + MANT) & 65535)\n\t      + A1S) & 65535) + AP) & 65535)
 + EXP) & 65535;\n  SEZ = DQS >> 1;\n  *S_E = SE = ( (((DQS + WA2) & 65535) + WA
1) & 65535 )>> 1;\n  \n  /* STATE update */\n  PK2 = PK1;\n  PK1 = PK0;\n  SR2 =
 SR1;\n  *A_2 = A2 = A2R;\n\n  for (EXP = 0; EXP < 6; EXP++)\n    B[EXP] = BP[EX
P];\n\n  DQ7 = DQ6;\n  DQ6 = DQ5;\n  DQ5 = DQ4;\n  DQ4 = DQ3;\n  DQ3 = DQ2;\n  D
Q2 = DQSEZ;\n  \t\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
17
24
"register int *DQ;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@103
-1
1
@672
}
1
@667
1
1
0
0
1
#5{
8
9
"SIG_0034"
}
#5{
8
24
"SIG_0034"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
1
1
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
1
#5{
1
17
"0"
}
}
}
}
}
@694
@874
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"11"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
95
122
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n    *OUTPUT3++ =\n      *
INPUT++ ;\n  ENDLOOP\n"
}
#20{
16
1
#21{
1
1
0
0
0
0
@1155
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
11
19
"int *INPUT;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@7
-1
1
@664
}
1
@659
1
1
0
0
1
#5{
8
9
"SIG_0023"
}
#5{
8
24
"SIG_0023"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
11
12
"IADPT_QUANT"
}
#5{
75
91
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/iadpt_quant.gc"
}
#5{
11
27
"iadpt_quant"
}
#5{
11
27
"iadpt_quant"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"34"
}
}
#10{
0
0
0
0
0
0
0
1
0
0
#11{
13
1
1
1
0
0
#5{
4
20
"void"
}
#5{
11
27
"iadpt_quant"
}
#5{
367
369
"\n  static int qtab[] =\n    \[\n      2048, 4, 135, 213, 273, 323, 373, 425,\n
      425, 373, 323, 273, 213, 135, 4, 2048,\n    \] ;\n  register int DQL;\n  
\n  /* RECONST and ADDA */\n  DQL = (qtab[*I] + (*Y >> 2)) & 4095;\n  \n  /* ANT
ILOG */\n  *DQ   = ((*I & (1 << 3)) * (1 << 11)) +  (DQL & (1 << 11) ? 0 :\n\t  
(((1 << 7) + (DQL & 127)) << 7) >> (14 - ((DQL >> 7) & 15)));\n  \n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
16
24
"register int *Y;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
@500
-1
1
@636
}
1
@631
1
1
0
0
1
#5{
8
9
"SIG_0040"
}
#5{
8
24
"SIG_0040"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@609
@945
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"13"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
95
122
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n    *OUTPUT3++ =\n      *
INPUT++ ;\n  ENDLOOP\n"
}
#20{
16
1
#21{
1
1
0
0
0
0
@1211
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
13
19
"int *OUTPUT2;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
2
1
#5{
7
22
"OUTPUT2"
}
-1
1
@608
}
1
1
0
0
1
#5{
8
9
"SIG_0041"
}
#5{
8
24
"SIG_0041"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@808
@753
16
1
@582
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
13
14
"SPEED_CONTROL"
}
#5{
77
93
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/speed_control.gc"
}
#5{
13
29
"speed_control"
}
#5{
13
29
"speed_control"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"21"
}
}
#10{
0
1
0
0
0
0
0
1
0
0
#18{
16
3
#19{
1
#4{
1
#5{
17
24
"register int DMS;"
}
}
}
#19{
1
#4{
1
#5{
17
24
"register int DML;"
}
}
}
#19{
1
#4{
1
#5{
16
24
"register int AP;"
}
}
}
}
#11{
16
1
1
1
0
0
#5{
4
20
"void"
}
#5{
13
29
"speed_control"
}
#5{
1473
1481
"\n  static int F[] = \[ 0, 0, 0, 1, 1, 1, 3, 7 \];\n  register int FI, tmp ; \n
\n  /* FUNTCF */\n  \n  FI = F[(*L >> 3 ? (15 - *L) : *L) & 7] ; \n\n  /* FILTA 
routine \n     Update of the short term average of F[l] */\n\n  tmp = ( (FI<<9) 
+ 8192 - DMS ) & 8191 ; \n  tmp = (tmp >> 12) ? (tmp >> 5) + 3840 : (tmp >> 5) ;
\n  DMS = (tmp + DMS) & 4095 ;  \n\n  /* FILTB routine \n     Update of the long
 term average of F[l] */\n\n  tmp = ( (FI<<11) + 32768 - DML ) & 32767 ; \n  tmp
 = (tmp >> 14) ? (tmp >> 7) + 16128 : (tmp >> 7) ;\n  DML = (tmp + DML) & 16383 
; \n\n  /* SUBTC routine */\n  /* Compute magnitude of the difference of short a
nd long term functions\n   of quantizer output sequence and then perform thresho
ld comparison\n   for quantizing speed control parameter \n  */\n\n  tmp = ( (DM
S << 2) + 32768  - DML ) & 32767  ;\n  tmp = (tmp >> 14) ? (32768 - tmp) & 16383
 : tmp ; \n\n  /* FI is now the speed control parameter update */\n  /* 1536 d =
 0011000000000 for SM 13 (3.-9) is 3 */\n\n  FI = ( (*Y >= 1536) && (tmp < (DML 
>> 3) ) && ((*TDP & 0x1) == 0) ) \n       ? 0 : 1;\n\n /* FILTC : low pass filte
r of speed control parameter */\n \n  tmp = ((FI << 9) + 2048 - AP) & 2047 ; \n 
 tmp = (tmp >> 10) ? (tmp >> 4) & 896 : (tmp >> 4) ; \n  tmp = (tmp + AP) & 1023
 ; \n\n /* TRIGA: Speed control trigger funcion */\n\n  AP = ((*TR & 0x1) == 1) 
?  256 : tmp ; \n\n  /* G.721 recommendation p.250 (LIMA Function) */\n  /* 256 
= 0100000000 bin = 1 for a 10SM 1.-8 value */\n\n  *AL = (AP > 255) ? 64 : AP >>
 2; \n\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
17
24
"register int *AL;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@421
-1
1
@581
}
1
1
0
0
1
#5{
8
9
"SIG_0033"
}
#5{
8
24
"SIG_0033"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
2
@616
@733
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
12
13
"SCALE_FACTOR"
}
#5{
76
92
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/scale_factor.gc"
}
#5{
12
28
"scale_factor"
}
#5{
12
28
"scale_factor"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"39"
}
}
#10{
0
1
0
0
0
0
0
1
0
0
#18{
16
2
#19{
1
#4{
1
#5{
17
24
"register int Y_L;"
}
}
}
#19{
1
#4{
1
#5{
20
24
"register int LAST_Y;"
}
}
}
}
#11{
15
1
1
1
0
0
#5{
4
20
"void"
}
#5{
12
28
"scale_factor"
}
#5{
1373
1381
"\n  static int W[] = \n    \[\n      4084, 18, 41, 64, 112, 198, 255, 1122\n   
 \] ; \n  \n  register int TMP, YUP, YLP ;\n  \n  /* FUNCTW, map quantizer outpu
t into \n     logarithmic version of scale factor multiplier */\n  \n  TMP = W[(
*L>>3) ? (15-*L) & 7 : *L & 7] ;\n  \n  /* FILTD, update of fast quantizer scale
 factor */\n  \n  TMP = ((TMP<<5) + 131072 - LAST_Y) & 131071 ; \n  YUP = (TMP>>
16) ? (TMP>>5) + 4096 : (TMP>>5) ; \n  YUP = (YUP + LAST_Y) & 8191 ; \n  \n  /* 
LIMB, limit quantizer scale factor */\n  \n    /* Set upper limit to 10.0 */\n  
if (( ( (YUP + 11264) & 16383) >> 13) == 0) YUP = 5120 ; \n    /* Set lower limi
t to 1.06 */\n  if (( ( (YUP + 15840) & 16383) >> 13) == 1) YUP = 544  ; \n  \n 
 /* FILTE, update of slow quantizer scale factor */\n  \n  TMP = (YUP + ((104857
6 - Y_L) >> 6)) & 16383 ; \n  TMP = (TMP >> 13) ? TMP + 507904 : TMP ; \n  YLP =
 (TMP + Y_L) & 524287 ; \n  \n  /* MIX, form linear combination of fast and slow
 quantizer scale factors */\n  \n  TMP    = (YUP + 16384 - (Y_L >> 6)) & 16383 ;
 \n  LAST_Y =  TMP >> 13 ; /* LAST_Y is used here as a temp variable */\n  TMP  
  = (LAST_Y == 1) ? (16384 - TMP) & 8191  : TMP ; \n  TMP    = (TMP * *AL) >> 6 
; \n  TMP    = (LAST_Y == 1) ? (16384 - TMP) & 16383 : TMP ; \n  \n  /* calculat
e new Y */\n  /* Output samples */\n  /* Store new states */\n \n  LAST_Y = *Y =
 ((Y_L >> 6) + TMP) & 8191 ; \n  *YL = Y_L ; \n  Y_L = YLP ;\n\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
16
24
"register int *L;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@285
-1
1
@574
}
1
@569
1
1
0
0
1
#5{
8
9
"SIG_0045"
}
#5{
8
24
"SIG_0045"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@644
@589
@287
@316
@32
@903
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"17"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
163
186
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n    *OUTPUT3++ =\n    *OU
TPUT4++ =\n    *OUTPUT5++ =\n    *OUTPUT6++ =\n    *OUTPUT7++ =\n      *INPUT++ 
;\n  ENDLOOP\n"
}
#20{
16
1
#21{
1
1
0
0
0
0
@1312
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
13
19
"int *OUTPUT6;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
6
1
#5{
7
22
"OUTPUT6"
}
-1
1
@31
}
1
1
0
0
1
#5{
8
9
"SIG_0050"
}
#5{
8
24
"SIG_0050"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@496
16
1
@24
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
11
12
"IADPT_QUANT"
}
#5{
75
91
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/iadpt_quant.gc"
}
#5{
11
27
"iadpt_quant"
}
#5{
11
27
"iadpt_quant"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"22"
}
}
#10{
0
0
0
0
0
0
0
1
0
0
#11{
13
1
1
1
0
0
#5{
4
20
"void"
}
#5{
11
27
"iadpt_quant"
}
#5{
367
369
"\n  static int qtab[] =\n    \[\n      2048, 4, 135, 213, 273, 323, 373, 425,\n
      425, 373, 323, 273, 213, 135, 4, 2048,\n    \] ;\n  register int DQL;\n  
\n  /* RECONST and ADDA */\n  DQL = (qtab[*I] + (*Y >> 2)) & 4095;\n  \n  /* ANT
ILOG */\n  *DQ   = ((*I & (1 << 3)) * (1 << 11)) +  (DQL & (1 << 11) ? 0 :\n\t  
(((1 << 7) + (DQL & 127)) << 7) >> (14 - ((DQL >> 7) & 15)));\n  \n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
17
24
"register int *DQ;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@663
-1
1
@23
}
1
1
0
0
1
#5{
8
9
"SIG_0006"
}
#5{
8
24
"SIG_0006"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
2
@17
@105
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"18"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
78
80
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n      *INPUT++ ;\n  ENDLO
OP\n"
}
#20{
16
1
#21{
1
1
0
0
0
0
@1369
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
13
19
"int *OUTPUT1;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
#5{
7
23
"OUTPUT1"
}
-1
1
@16
}
1
1
0
0
1
#5{
8
9
"SIG_0052"
}
#5{
8
24
"SIG_0052"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
@149
@438
16
2
@9
@379
0
1
0
0
@1
1
1
0
0
#9{
1
0
1
1
1
1
0
0
1
1
#5{
13
14
"TONE_DETECTOR"
}
#5{
77
93
"/tools/home1/martinez/cossap/ariel56k/d/opt_adpcm/dspgeneric/tone_detector.gc"
}
#5{
13
29
"tone_detector"
}
#5{
13
29
"tone_detector"
}
#5{
2
18
"GC"
}
#5{
16
32
"DSP_CODE_GENERIC"
}
#5{
2
16
"36"
}
}
#10{
0
1
0
0
0
0
0
1
0
0
#18{
16
2
#19{
1
#4{
1
#5{
18
24
"register int t_dr;"
}
}
}
#19{
1
#4{
1
#5{
21
24
"register int LAST_TR;"
}
}
}
}
#11{
14
1
1
1
0
0
#5{
4
20
"void"
}
#5{
13
29
"tone_detector"
}
#5{
545
556
"\n  register int tmp ; \n  register int t_d ; \n\n  /* partial band signal dete
ction */\n  *T_DP = ( (*A_2 > 32769) && (*A_2 < 53761) ) ? 1 : 0 ; \n  \n  /* ta
ke last t_dr */\n  t_d = t_dr ;\n  \n  /* calcutale new t_dr */\n  /* TRIGB Func
tion */\n  t_dr = (LAST_TR == 0) ? *T_DP : 0 ; \n  \n  LAST_TR = *YL >> 15 ; /* 
LAST_TR is used here as a temporary variable */\n  \n  tmp = (LAST_TR > 8) ? \n 
   31 << 9 : (32 + ((LAST_TR << 5) & 31)) << LAST_TR ; \n  \n  LAST_TR = *TR = (
 ((*DQ & 16383) > (tmp + (tmp >> 1) ) >> 1) \n\t\t   && (t_d == 1) )  ?  \n\t\t 
    1 : 0;\n"
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
1
1
#4{
1
#5{
17
24
"register int *TR;"
}
}
#6{
1
16
"1"
1
16
"1"
0
}
1
1
@791
-1
1
@8
}
1
1
0
0
1
#5{
8
9
"SIG_0009"
}
#5{
8
24
"SIG_0009"
}
#4{
1
#5{
4
19
"int;"
}
}
0
0
0
0
-1
0
0
0
-1
#14{
16
1
#15{
0
}
}
#14{
16
1
#15{
0
}
}
#16{
16
1
#17{
16
0
}
}
}
}
16
2
@358
@127
0
1
0
0
@1
1
1
0
0
#9{
1
0
0
0
1
1
0
0
1
1
#5{
6
7
"FORK_I"
}
#5{
4
20
"fork"
}
#5{
9
25
"GENERATED"
}
#5{
14
30
"SELF_GENERATED"
}
#5{
2
16
"19"
}
}
#10{
1
0
0
0
0
0
0
1
0
0
#5{
6
22
"nBlock"
}
#11{
1
0
1
1
0
1
#5{
4
20
"fork"
}
#5{
78
80
"  LOOP( nBlock) \n    *OUTPUT1++ =\n    *OUTPUT2++ =\n      *INPUT++ ;\n  ENDLO
OP\n"
}
#20{
16
1
#21{
1
1
0
0
0
0
@1433
#5{
7
23
" nBlock"
}
1528826122
3
16
"for"
1
#6{
7
16
" nBlock"
6
16
"nBlock"
1
}
1
0
}
}
0
}
0
0
0
}
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
}
@18
@33
@859
@610
@273
@666
@681
@56
@576
@638
@48
@583
@280
@40
@688
@674
@867
@309
@25
@896
@10
@967
@98
0
0
0
0
0
0
1
0
#5{
6
22
"SIGNAL"
}
0
0
1
0
0
0
1
}
