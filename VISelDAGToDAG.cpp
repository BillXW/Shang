//===----------- VDAGToDAG.cpp - A dag to dag inst selector for VTM -------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the VTM target.
//
//===----------------------------------------------------------------------===//

#include "VTargetMachine.h"

#include "vtm/VInstrInfo.h"

#include "llvm/Intrinsics.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
/// VTMDAGToDAGISel - VTM specific code to select VTM instructions for
/// SelectionDAG operations.
namespace {
class VDAGToDAGISel : public SelectionDAGISel {
public:
  VDAGToDAGISel(VTargetMachine &TM, CodeGenOpt::Level OptLevel)
    : SelectionDAGISel(TM, OptLevel) {}

  virtual const char *getPassName() const {
    return "VTM DAG->DAG Pattern Instruction Selection";
  }

  // Include the pieces autogenerated from the target description.
#include "VGenDAGISel.inc"

private:
  // The last operand of all VTM machine instructions is the bit width operand,
  // which hold the bit width information of all others operands. This operand
  // is a 64 bit immediate.
  void computeOperandsBitWidth(SDNode *N, SDValue Ops[], size_t NumOps);

  SDNode *Select(SDNode *N);
  SDNode *SelectUnary(SDNode *N, unsigned OpC);
  SDNode *SelectBinary(SDNode *N, unsigned OpC);
  SDNode *SelectSimpleNode(SDNode *N, unsigned OpC);

  // Function argument and return values.
  SDNode *SelectInArg(SDNode *N);
  SDNode *SelectRetVal(SDNode *N);
  SDNode *SelectBrcnd(SDNode *N);

  // Arithmetic operations.
  SDNode *SelectAdd(SDNode *N);

  SDNode *SelectConstant(SDNode *N);

  SDNode *SelectMemAccess(SDNode *N);
  SDNode *SelectBRamAccess(SDNode *N);
  
  SDNode *SelectINTRINSIC_W_CHAIN(SDNode *N);

  virtual void PostprocessISelDAG();
  void FixCopyConst(SelectionDAG &DAG, SDNode *N);

  const VInstrInfo &getInstrInfo() {
    return *static_cast<const VTargetMachine&>(TM).getInstrInfo();
  }
  const VRegisterInfo *getRegisterInfo() {
    return static_cast<const VTargetMachine&>(TM).getRegisterInfo();
  }
};
}  // end anonymous namespace

FunctionPass *llvm::createVISelDag(VTargetMachine &TM,
                                   CodeGenOpt::Level OptLevel) {
  return new VDAGToDAGISel(TM, OptLevel);
}

void VDAGToDAGISel::computeOperandsBitWidth(SDNode *N, SDValue Ops[],
                                            size_t NumOps) {
  BitWidthAnnotator Annotator;
  unsigned NumDefs = 0;

  for (unsigned i = 0; i < N->getNumValues(); ++i) {
    // Since chains will not appear in the machine instructions, we need to skip
    // them.
    if (N->getValueType(i) == MVT::Other)
      continue;

    Annotator.setBitWidth(VTargetLowering::computeSizeInBits(SDValue(N, i)), NumDefs);
    ++NumDefs;
  }

  // Set up the operand widths.
  for (unsigned i = 0; i < NumOps -1; ++i) {
    if (Ops[i].getValueType() == MVT::Other) continue;
    
    Annotator.setBitWidth(VTargetLowering::computeSizeInBits(Ops[i]),
                    i + NumDefs); // Skip the chains.
  }
  
  // FIXME: Build the bit width information.
  Ops[NumOps -1] = CurDAG->getTargetConstant(Annotator.get(), MVT::i64);
}

SDNode *VDAGToDAGISel::SelectUnary(SDNode *N, unsigned OpC) {
  SDValue Ops [] = { N->getOperand(0),
                     SDValue()/*The dummy bit width operand*/ };

  computeOperandsBitWidth(N, Ops, array_lengthof(Ops));

  return CurDAG->SelectNodeTo(N, OpC, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectBinary(SDNode *N, unsigned OpC) {
  SDValue Ops [] = { N->getOperand(0), N->getOperand(1),
                     SDValue()/*The dummy bit width operand*/ };
  
  computeOperandsBitWidth(N, Ops, array_lengthof(Ops));

  return CurDAG->SelectNodeTo(N, OpC, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectAdd(SDNode *N) {
  //N->getValueType(0)
  SDValue Ops[] = { N->getOperand(0), N->getOperand(1), N->getOperand(2),
                    SDValue()/*The dummy bit width operand*/ };
  
  computeOperandsBitWidth(N, Ops, array_lengthof(Ops));

  return CurDAG->SelectNodeTo(N, VTM::VOpAdd, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectSimpleNode(SDNode *N, unsigned Opc) {
  SmallVector<SDValue, 4> Ops;
  for (SDNode::op_iterator I = N->op_begin(), E = N->op_end(); I != E; ++I)
    Ops.push_back(*I);

  Ops.push_back(SDValue());//The dummy bit width operand

  computeOperandsBitWidth(N, Ops.data(), Ops.size());
  
  return CurDAG->SelectNodeTo(N, Opc, N->getVTList(), Ops.data(), Ops.size());
}

SDNode *VDAGToDAGISel::SelectConstant(SDNode *N) {
  ConstantSDNode *CSD = cast<ConstantSDNode>(N);
  // Do not need to select target constant.
  if (CSD->getOpcode() == ISD::TargetConstant)
    return 0;
  
  // FIXME: We do not need this since we have the bit width operand to hold
  // the bit width of a constant.
  // Build the target constant.
  int64_t Val = CSD->getZExtValue();
  SDValue Const = CurDAG->getTargetConstant(Val, N->getValueType(0));

  SDValue Ops[] = { Const,
                    SDValue()/*The dummy bit width operand*/ };

  computeOperandsBitWidth(N, Ops, array_lengthof(Ops));

  return CurDAG->SelectNodeTo(N, VTM::VOpSetRI, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectInArg(SDNode *N) {
  // Build the target constant.
  SDValue ArgIdx = N->getOperand(1);
  int64_t Val = cast<ConstantSDNode>(ArgIdx)->getZExtValue();
  ArgIdx = CurDAG->getTargetConstant(Val, ArgIdx.getValueType());

  SDValue Ops[] = { ArgIdx, SDValue()/*The dummy bit width operand*/,
                    N->getOperand(0) };

  computeOperandsBitWidth(N, Ops, array_lengthof(Ops) -1 /*Skip the chain*/);

  return CurDAG->SelectNodeTo(N, VTM::VOpArg, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectBrcnd(SDNode *N) {
  SDValue Ops[] = {N->getOperand(1), N->getOperand(2),
                   SDValue()/*The dummy bit width operand*/,
                   N->getOperand(0) };
  computeOperandsBitWidth(N, Ops, array_lengthof(Ops) -1/*Skip the ch*/);

  return CurDAG->MorphNodeTo(N, ~VTM::VOpToState, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectRetVal(SDNode *N) {
  SDValue RetValIdx = N->getOperand(2);
  int64_t Val = cast<ConstantSDNode>(RetValIdx)->getZExtValue();
  RetValIdx = CurDAG->getTargetConstant(Val, RetValIdx.getValueType());

  SDValue Ops[] = { N->getOperand(1), RetValIdx,
                    SDValue()/*The dummy bit width operand*/,
                    N->getOperand(0) };

  computeOperandsBitWidth(N, Ops, array_lengthof(Ops) -1 /*Skip the chain*/);

  return CurDAG->SelectNodeTo(N, VTM::VOpRetVal, N->getVTList(),
                              Ops, array_lengthof(Ops));
}


SDNode *VDAGToDAGISel::SelectMemAccess(SDNode *N) {
  MachineSDNode::mmo_iterator MemOp = MF->allocateMemRefsArray(1);
  MemOp[0] = cast<MemSDNode>(N)->getMemOperand();

  SDValue Ops[] = { N->getOperand(1), N->getOperand(2), N->getOperand(3),
                    N->getOperand(4), SDValue()/*The dummy bit width operand*/,
                    N->getOperand(0) };

  computeOperandsBitWidth(N, Ops, array_lengthof(Ops) -1 /*Skip the chain*/);

  SDNode *Ret = CurDAG->SelectNodeTo(N, VTM::VOpMemTrans, N->getVTList(),
                                     Ops, array_lengthof(Ops));

  cast<MachineSDNode>(Ret)->setMemRefs(MemOp, MemOp + 1);
  return Ret;
}

SDNode *VDAGToDAGISel::SelectBRamAccess(SDNode *N) {
  MachineSDNode::mmo_iterator MemOp = MF->allocateMemRefsArray(1);
  MemOp[0] = cast<MemIntrinsicSDNode>(N)->getMemOperand();

  unsigned ArgIdx = 2;
  unsigned BRamNum = N->getConstantOperandVal(ArgIdx + 5);

  SDValue Ops[] = { N->getOperand(ArgIdx), N->getOperand(ArgIdx + 1),
                    N->getOperand(ArgIdx + 2),
                    // FIXME: Set the correct byte enable.
                    CurDAG->getTargetConstant(0, MVT::i32),
                    CurDAG->getTargetConstant(BRamNum, MVT::i32),
                    SDValue()/*The dummy bit width operand*/,
                    N->getOperand(0) };

  computeOperandsBitWidth(N, Ops, array_lengthof(Ops) -1 /*Skip the chain*/);

  SDNode *Ret = CurDAG->SelectNodeTo(N, VTM::VOpBRam, N->getVTList(),
                                     Ops, array_lengthof(Ops));

  cast<MachineSDNode>(Ret)->setMemRefs(MemOp, MemOp + 1);
  return Ret;
}

SDNode *VDAGToDAGISel::SelectINTRINSIC_W_CHAIN(SDNode *N) {
  unsigned IntNo = N->getConstantOperandVal(1);
  
  switch (IntNo) {
  default: break;
  case vtmIntrinsic::vtm_access_bram:
    return SelectBRamAccess(N);
  }

  return 0;
}

SDNode *VDAGToDAGISel::Select(SDNode *N) {
  if (N->isMachineOpcode())
    return 0;   // Already selected.

  switch (N->getOpcode()) {
  default: break;
  case VTMISD::RetVal:        return SelectRetVal(N);
  case VTMISD::InArg:         return SelectInArg(N);
  case ISD::BRCOND:           return SelectBrcnd(N);

  case VTMISD::ADD:           return SelectAdd(N);
  // DirtyHack: Is binary instruction enough?
  case ISD::MUL:              return SelectBinary(N, VTM::VOpMult);

  case ISD::XOR:              return SelectBinary(N, VTM::VOpXor);
  case ISD::AND:              return SelectBinary(N, VTM::VOpAnd);
  case ISD::OR:               return SelectBinary(N, VTM::VOpOr);
  case VTMISD::Not:           return SelectUnary(N, VTM::VOpNot);
  case ISD::SELECT:           return SelectSimpleNode(N, VTM::VOpSel);

  case ISD::SHL:              return SelectBinary(N, VTM::VOpSHL);
  case ISD::SRL:              return SelectBinary(N, VTM::VOpSRL);
  case ISD::SRA:              return SelectBinary(N, VTM::VOpSRA);

  case VTMISD::BitRepeat:     return SelectBinary(N, VTM::VOpBitRepeat);
  case VTMISD::BitCat:        return SelectBinary(N, VTM::VOpBitCat);
  case VTMISD::BitSlice:      return SelectSimpleNode(N, VTM::VOpBitSlice);

  case VTMISD::ROr:           return SelectUnary(N, VTM::VOpROr);
  case VTMISD::RAnd:          return SelectUnary(N, VTM::VOpRAnd);
  case VTMISD::RXor:          return SelectUnary(N, VTM::VOpRXor);

  case ISD::Constant:         return SelectConstant(N);

  case VTMISD::MemAccess:     return SelectMemAccess(N);
  case ISD::INTRINSIC_W_CHAIN: return SelectINTRINSIC_W_CHAIN(N);
  }

  return SelectCode(N);
}
static void UpdateNodeOperand(SelectionDAG &DAG,  SDNode *N, unsigned Num,
                              SDValue Val) {
  SmallVector<SDValue, 8> ops(N->op_begin(), N->op_end());
  ops[Num] = Val;
  SDNode *New = DAG.UpdateNodeOperands(N, ops.data(), ops.size());
  DAG.ReplaceAllUsesWith(N, New);
}

void VDAGToDAGISel::FixCopyConst(SelectionDAG &DAG, SDNode *Copy) {
  ConstantSDNode *CSD = dyn_cast<ConstantSDNode>(Copy->getOperand(2));
  // Only handle assign a constant value to register.
  if (!CSD) return;

  MachineSDNode *SetRI =
    CurDAG->getMachineNode(VTM::VOpSetRI, Copy->getDebugLoc(),
                           CSD->getValueType(0), SDValue(CSD, 0));
  UpdateNodeOperand(DAG, Copy, 2, SDValue(SetRI, 0));
}

void VDAGToDAGISel::PostprocessISelDAG() {
  CurDAG->AssignTopologicalOrder();
  HandleSDNode Dummy(CurDAG->getRoot());

  for (SelectionDAG::allnodes_iterator NI = CurDAG->allnodes_begin();
       NI != CurDAG->allnodes_end(); ++NI) {
    if (NI->getOpcode() == ISD::CopyToReg)
      FixCopyConst(*CurDAG, NI);
  }
  CurDAG->setRoot(Dummy.getValue());
}
