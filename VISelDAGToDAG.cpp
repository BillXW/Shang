//===----------- VDAGToDAG.cpp - A dag to dag inst selector for VTM -------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the VTM target.
//
//===----------------------------------------------------------------------===//

#include "VTM.h"
#include "VTargetMachine.h"
#include "VRegisterInfo.h"
#include "llvm/Intrinsics.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
/// VTMDAGToDAGISel - VTM specific code to select VTM instructions for
/// SelectionDAG operations.
namespace {
class VDAGToDAGISel : public SelectionDAGISel {
public:
  VDAGToDAGISel(VTargetMachine &TM, CodeGenOpt::Level OptLevel)
    : SelectionDAGISel(TM, OptLevel) {}

  virtual const char *getPassName() const {
    return "VTM DAG->DAG Pattern Instruction Selection";
  }

  // Include the pieces autogenerated from the target description.
#include "VGenDAGISel.inc"

private:
  SDNode *Select(SDNode *N);
  SDNode *SelectBinary(SDNode *N, unsigned OpC);

  // Function argument and return values.
  SDNode *SelectInArg(SDNode *N);
  SDNode *SelectRetVal(SDNode *N);

  // Arithmetic operations.
  SDNode *SelectAdd(SDNode *N);


  SDNode *SelectCast(SDNode *N, bool Signed = false);
  SDNode *SelectConstant(SDNode *N);

  SDNode *SelectLoad(SDNode *N);

  const VInstrInfo &getInstrInfo() {
    return *static_cast<const VTargetMachine&>(TM).getInstrInfo();
  }
  const VRegisterInfo *getRegisterInfo() {
    return static_cast<const VTargetMachine&>(TM).getRegisterInfo();
  }
};
}  // end anonymous namespace

FunctionPass *llvm::createVISelDag(VTargetMachine &TM,
                                   CodeGenOpt::Level OptLevel) {
  return new VDAGToDAGISel(TM, OptLevel);
}

SDNode *VDAGToDAGISel::SelectBinary(SDNode *N, unsigned OpC) {
  SDValue Ops [] = { N->getOperand(0), N->getOperand(1) };
  return CurDAG->SelectNodeTo(N, OpC, N->getVTList(),
    Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectAdd(SDNode *N) {
  //N->getValueType(0)
  SDValue Ops[] = { N->getOperand(0), N->getOperand(1), N->getOperand(2)};
  return CurDAG->SelectNodeTo(N, VTM::VOpAdd, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectCast(SDNode *N, bool Signed) {
  SDValue Ops[] = { N->getOperand(0), CurDAG->getTargetConstant(Signed,
                    MVT::i1) };
  return CurDAG->SelectNodeTo(N, VTM::VOpCast, N->getVTList(),
                              Ops, array_lengthof(Ops));
}


SDNode * VDAGToDAGISel::SelectConstant(SDNode *N) {
  // Build the target constant.
  int64_t Val = cast<ConstantSDNode>(N)->getZExtValue();
  SDValue Const = CurDAG->getTargetConstant(Val, N->getValueType(0));

  SDValue Ops[] = { Const };
  return CurDAG->SelectNodeTo(N, VTM::VOpLdImm, N->getVTList(),
                              Ops, array_lengthof(Ops));
}


SDNode * VDAGToDAGISel::SelectInArg(SDNode *N) {
  // Build the target constant.
  SDValue ArgIdx = N->getOperand(1);
  int64_t Val = cast<ConstantSDNode>(ArgIdx)->getZExtValue();
  ArgIdx = CurDAG->getTargetConstant(Val, ArgIdx.getValueType());

  SDValue Ops[] = { ArgIdx, N->getOperand(0) };
  return CurDAG->SelectNodeTo(N, VTM::VOpArg, N->getVTList(),
                              Ops, array_lengthof(Ops));
}

SDNode *VDAGToDAGISel::SelectRetVal(SDNode *N) {
  SDValue RetValIdx = N->getOperand(2);
  int64_t Val = cast<ConstantSDNode>(RetValIdx)->getZExtValue();
  RetValIdx = CurDAG->getTargetConstant(Val, RetValIdx.getValueType());

  SDValue Ops[] = { N->getOperand(1), RetValIdx, N->getOperand(0) };
  return CurDAG->SelectNodeTo(N, VTM::VOpRetVal, N->getVTList(),
                              Ops, array_lengthof(Ops));
}


SDNode *VDAGToDAGISel::SelectLoad(SDNode *N) {
  MachineSDNode::mmo_iterator MemOp = MF->allocateMemRefsArray(1);
  MemOp[0] = cast<MemSDNode>(N)->getMemOperand();

  SDValue Ops[] = { N->getOperand(1), N->getOperand(0) };
  SDNode *Ret = CurDAG->SelectNodeTo(N, VTM::VOpLoad, N->getVTList(),
                                     Ops, array_lengthof(Ops));

  cast<MachineSDNode>(Ret)->setMemRefs(MemOp, MemOp + 1);
  return Ret;
}

SDNode *VDAGToDAGISel::Select(SDNode *N) {
  if (N->isMachineOpcode())
    return NULL;   // Already selected.

  switch (N->getOpcode()) {
  default: break;
  case VTMISD::RetValDAG:     return SelectRetVal(N);
  case VTMISD::InArgDAG:      return SelectInArg(N);

  case VTMISD::ADDDAG:        return SelectAdd(N);

  case ISD::XOR:              return SelectBinary(N, VTM::VOpXor);

  case ISD::SHL:              return SelectBinary(N, VTM::VOpSHL);

  case ISD::SIGN_EXTEND:      return SelectCast(N, true);
  case ISD::ANY_EXTEND:
  case ISD::ZERO_EXTEND:
  case ISD::TRUNCATE:         return SelectCast(N);
  case ISD::Constant:         return SelectConstant(N);

  case ISD::LOAD:             return SelectLoad(N);
  }

  return SelectCode(N);
}

static void UpdateNodeOperand(SelectionDAG &DAG, SDNode *N, unsigned Num,
                              SDValue Val) {
  SmallVector<SDValue, 8> ops(N->op_begin(), N->op_end());
  ops[Num] = Val;
  SDNode *New = DAG.UpdateNodeOperands(N, ops.data(), ops.size());
  DAG.ReplaceAllUsesWith(N, New);
}
